<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Clash Royale Imposter</title>
  <link rel="preconnect" href="https://raw.githubusercontent.com" />
  <style>
    :root { --bg:#0f172a; --panel:#0b1220; --text:#e5e7eb; --muted:#94a3b8; --accent:#22c55e; --danger:#ef4444; --primary:#0ea5e9; }
    *{box-sizing:border-box;font-family:system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif}
    body{margin:0;min-height:100vh;background:linear-gradient(180deg,#0a0f1c,#0f172a);color:var(--text);display:flex;align-items:center}
    .wrap{width:100%;max-width:760px;margin:0 auto;padding:20px}
    .card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:20px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    h1{margin:0 0 10px;font-size:28px}
    p.sub{margin:0 0 16px;color:var(--muted)}
    .modebar{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:10px}
    .modebtn{padding:10px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(56,189,248,.1);color:#c7f9ff;font-weight:700}
    .modebtn.primary{background:#38bdf8;color:#031d2c}
    .modebtn.disabled{opacity:.5;cursor:not-allowed}
    label{display:block;margin:8px 0 4px;color:var(--muted);font-size:14px}
    input{width:100%;padding:12px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0e1526;color:var(--text)}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .btn{width:100%;padding:14px 16px;border-radius:14px;border:1px solid rgba(255,255,255,.1);background:#152235;color:var(--text);font-weight:800;font-size:16px;cursor:pointer}
    .btn.primary{background:var(--primary);border-color:rgba(14,165,233,.5)}
    .btn.success{background:var(--accent);color:#052e16;border:none}
    .btn.danger{background:var(--danger);border:none}
    .center{display:flex;flex-direction:column;align-items:center;text-align:center;gap:14px}
    .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);font-size:12px;color:var(--muted)}
    .divider{height:1px;background:rgba(255,255,255,.08);margin:12px 0}
    .hidden{display:none}
    .wordStage{display:grid;grid-template-columns:1fr;gap:16px;width:100%}

    .wordCard{border-radius:24px;border:2px dashed rgba(255,255,255,.15);padding:16px 16px 20px;min-height:300px;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;gap:12px}
    .wordText{font-size:36px;font-weight:800;letter-spacing:.4px;text-align:center;word-break:break-word;max-width:100%}

    .imageSlot{width:100%;max-width:320px;aspect-ratio:1/1;display:flex;align-items:center;justify-content:center;border-radius:18px;border:1px dashed rgba(255,255,255,.14);background:rgba(255,255,255,.02)}
    #cardImg{max-width:100%;max-height:100%;object-fit:contain;display:none}

    .hint{color:var(--muted);font-size:14px;margin-top:-6px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="modebar">
      <button class="modebtn primary" id="modeClash" type="button">Clash Royale Imposter</button>
      <button class="modebtn" id="modeDark" type="button">Clash Royale in the Dark</button>
      <button class="modebtn disabled" id="modeCustom" type="button">Custom Word Imposter</button>
    </div>

    <div class="card" id="screen-setup">
      <h1>Clash Royale Imposter</h1>
      <p class="sub">Add players and impostors, then start. The word list is hidden. Extra space is reserved for card images.</p>

      <div class="row">
        <div>
          <label for="players">Players</label>
          <input id="players" type="number" min="3" max="20" value="6" />
        </div>
        <div>
          <label for="impostors">Impostors (â‰¤ players)</label>
          <input id="impostors" type="number" min="1" value="1" />
        </div>
      </div>

      <div class="row" id="darkControls" style="margin-top:12px; display:none">
        <div>
          <label for="darkDifficulty">Dark Mode Difficulty</label>
          <select id="darkDifficulty" style="width:100%;padding:12px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0e1526;color:var(--text)">
            <option value="easy">Easy (same type)</option>
            <option value="medium">Medium (same type)</option>
            <option value="hard">Hard (mostly random)</option>
            <option value="chaos">Chaos (random)</option>
          </select>
        </div>
        <div></div>
      </div>

      <div class="row" style="margin-top:12px">
        <button class="btn primary" id="begin" type="button">Begin Round</button>
        <button class="btn danger" id="resetAllSetup" type="button">Reset</button>
      </div>
    </div>

    <div class="card hidden" id="screen-pass">
      <div class="center" style="width:100%">
        <div class="pill" id="turnInfo">Player 1 / ?</div>
        <div class="wordStage">
          <div class="wordCard">
            <div class="imageSlot">
              <img id="cardImg" alt="Card" />
            </div>
            <div class="wordText" id="wordText">Tap to reveal</div>
          </div>
          <div class="hint" id="hint">Hand the phone to this player before tapping.</div>
        </div>
        <button class="btn success" id="toggleBtn" type="button" style="width:100%">Reveal</button>
      </div>
    </div>

    <div class="card hidden" id="screen-summary">
      <div class="center">
        <div class="pill">Round finished</div>
        <h1>How to Play</h1>
        <p class="sub" style="max-width:640px">
          Most players saw the same Clash Royale card. Impostors saw <b>IMPOSTOR</b> instead. Discuss clues about the secret card without giving it away.
        </p>
        <button class="btn" id="showImpostors" type="button">Reveal Impostors</button>
        <div id="impostorList" class="sub hidden"></div>
        <div class="divider"></div>
        <button class="btn primary" id="playAgain" type="button">Play Again</button>
      </div>
    </div>
  </div>

  <script>
    // ---------------- Data -----------------
    const CLASH_CARDS = [
      'Arrows','Zap','Snowball','Rage','Clone','Mirror','Heal Spirit','Fireball','Poison','Rocket','Lightning','Earthquake','Tornado','The Log','Barbarian Barrel','Royal Delivery',
      'Skeletons','Ice Spirit','Fire Spirits','Bats','Spear Goblins','Goblins','Goblin Gang','Guards','Skeleton Army','Wall Breakers',
      'Archers','Knight','Bomber','Ice Golem','Minions','Minion Horde','Dart Goblin','Goblin Cage','Goblin Hut','Barbarian Hut','Barbarians','Royal Recruits','Royal Hogs','Zappies','Rascals',
      'Musketeer','Hunter','Wizard','Ice Wizard','Electro Wizard','Magic Archer','Mother Witch',
      'Valkyrie','Mini P.E.K.K.A','Dark Prince','Prince','Bandit','Battle Ram','Cannon Cart','Ram Rider','Lumberjack','Battle Healer','Fisherman','Monk',
      'P.E.K.K.A','Giant','Giant Skeleton','Goblin Giant','Royal Giant','Hog Rider','Mega Knight','Sparky','Balloon','X-Bow','Mortar','Cannon','Bomb Tower','Tesla','Inferno Tower','Furnace','Tombstone',
      'Baby Dragon','Inferno Dragon','Electro Dragon','Skeleton Dragons','Phoenix',
      'Mega Minion','Minion Horde','Flying Machine',
      'Golem','Lava Hound','Graveyard','Miner','Goblin Barrel','Goblin Drill','Elixir Golem','Electro Giant',
      'Three Musketeers','Elixir Collector','Spirit Empress','Berserker','Goblin Curse','Goblin Machine','Void','Vines','Goblin Demolisher','Suspicious Bush','Rune Giant',
      'Archer Queen','Skeleton King','Golden Knight','Mighty Miner','Little Prince','Goblinstein'
    ];

    const RAW_BASE = "https://raw.githubusercontent.com/methmonster34/clash-royale-impostor/main";
    const IMAGE_FOLDERS = ["Clash Royale Imposter Images", "Clash Royale Imposter Images 2"]; // keep both

    // --------------- Helpers ----------------
    const el = id => document.getElementById(id);
    const screens = { setup: el("screen-setup"), pass: el("screen-pass"), summary: el("screen-summary") };
    let mode = 'clash'; // 'clash' | 'dark'
    const show = name => { Object.values(screens).forEach(s => s.classList.add("hidden")); screens[name].classList.remove("hidden"); };

    function filenameForCard(name){ return name.toLowerCase().replace(/[^a-z0-9]/g,'') + '.png'; }

    function setCardImage(name){
      const img = el('cardImg');
      const file = filenameForCard(name);
      const urls = IMAGE_FOLDERS.map(folder => `${RAW_BASE}/${encodeURIComponent(folder)}/${file}`);

      img.style.display = 'none';
      img.loading = 'eager';
      img.decoding = 'async';

      let i = 0;
      function tryNext(){
        if(i >= urls.length){ img.removeAttribute('src'); img.style.display='none'; return; }
        const url = urls[i];
        img.onerror = () => { i++; tryNext(); };
        img.onload  = () => { img.style.display = 'block'; };
        img.src = url; // allow cache for speed
      }
      tryNext();
    }

    function prefetchCardImage(name){
      const file = filenameForCard(name);
      IMAGE_FOLDERS.forEach(folder => {
        const i = new Image();
        i.decoding = 'async';
        i.src = `${RAW_BASE}/${encodeURIComponent(folder)}/${file}`;
      });
    }

    // --------------- State ------------------
    let state = { players:6, impostors:1, assignments:[], word:"", turn:0, revealed:false, history:[], impostorAlts:[] };

    function clampImpostors(){
      const p = state.players;
      if(state.impostors < 1) state.impostors = 1;
      if(state.impostors > p) state.impostors = p;
      el('impostors').value = String(state.impostors);
    }

    function readSetup(){
      state.players = Math.max(3, Math.min(20, parseInt(el('players').value || '6')));
      state.impostors = parseInt(el('impostors').value || '1');
      clampImpostors();
    }

    function randomWord(){
      state.word = CLASH_CARDS[Math.floor(Math.random()*CLASH_CARDS.length)];
      prefetchCardImage(state.word);
    }

    function assignRoles(){
      const arr = Array(state.players).fill('WORD');
      const impCount = Math.min(state.impostors, state.players);
      const used = new Set();
      while(used.size < impCount) used.add(Math.floor(Math.random()*state.players));
      for(const i of used) arr[i] = 'IMPOSTOR';
      state.assignments = arr;
      state.impostorAlts = Array(state.players).fill(null);
      if(mode === 'dark'){
        // choose alt card for impostors
        const alts = [];
        for(let i=0;i<state.players;i++){
          if(arr[i] === 'IMPOSTOR'){
            const alt = pickSimilar(state.word, el('darkDifficulty')?.value || 'easy');
            state.impostorAlts[i] = alt;
            alts.push(alt);
          }
        }
        // prefetch impostor images too
        alts.forEach(a => prefetchCardImage(a));
      }
      state.turn = 0; state.revealed = false; state.history = [];
    }

    function updatePassUI(){
      el('turnInfo').textContent = `Player ${state.turn+1} / ${state.players}`;
      const img = el('cardImg');

      if(!state.revealed){
        el('wordText').textContent = 'Tap to reveal';
        el('wordText').style.color = 'var(--text)';
        el('hint').textContent = 'Hand the phone to this player before tapping.';
        el('toggleBtn').textContent = 'Reveal';
        img.removeAttribute('src');
        img.style.display = 'none';
      } else {
        const isImp = state.assignments[state.turn] === 'IMPOSTOR';
        let roleText, cardName;
        if(isImp && mode === 'dark'){
          cardName = state.impostorAlts[state.turn] || state.word;
          roleText = cardName; // impostor sees a legit-looking card
          el('wordText').style.color = 'var(--text)';
          setCardImage(cardName);
        } else if(isImp){
          roleText = 'IMPOSTOR';
          el('wordText').style.color = 'var(--danger)';
          img.removeAttribute('src'); img.style.display='none';
        } else {
          cardName = state.word;
          roleText = state.word;
          el('wordText').style.color = 'var(--text)';
          setCardImage(cardName);
        }
        el('wordText').textContent = roleText;
        el('hint').textContent = state.turn === state.players-1 ? 'Last player revealed. Tap again to finish.' : 'Tap Next Player and pass the phone.';
        el('toggleBtn').textContent = state.turn === state.players-1 ? 'Finish Round' : 'Next Player';
      }
    }

    function nextTurn(){
      state.history.push({ player: state.turn+1, role: state.assignments[state.turn] });
      state.turn++;
      state.revealed = false;
      if(state.turn >= state.players){
        show('summary');
        el('impostorList').classList.add('hidden');
        el('impostorList').textContent = '';
        return;
      }
      updatePassUI();
    }

    // -------------- Events ------------------
    el('players').addEventListener('input', () => {
      state.players = Math.max(3, Math.min(20, parseInt(el('players').value || '6')));
      clampImpostors();
    });
    el('impostors').addEventListener('input', () => {
      state.impostors = parseInt(el('impostors').value || '1');
      clampImpostors();
    });

    el('begin').onclick = () => { readSetup(); randomWord(); assignRoles(); show('pass'); updatePassUI(); };
    el('resetAllSetup').onclick = () => { el('players').value = '6'; el('impostors').value = '1'; state.players=6; state.impostors=1; };
    el('toggleBtn').onclick = () => { if(!state.revealed){ state.revealed = true; updatePassUI(); } else { nextTurn(); } };
    el('showImpostors').onclick = () => {
      const list = state.history.filter(h => h.role === 'IMPOSTOR').map(h => `Player ${h.player}`).join(', ');
      el('impostorList').textContent = list ? `Impostors: ${list}` : 'No impostors recorded.';
      el('impostorList').classList.remove('hidden');
    };
    el('playAgain').onclick = () => { show('setup'); };

    // -------- Mode switching --------
    function setMode(newMode){
      mode = newMode;
      // visual toggle
      el('modeClash').classList.toggle('primary', mode==='clash');
      el('modeDark').classList.toggle('primary', mode==='dark');
      // show difficulty for dark
      el('darkControls').style.display = mode==='dark' ? 'grid' : 'none';
    }
    el('modeClash').onclick = () => setMode('clash');
    el('modeDark').onclick = () => setMode('dark');
  // -------- Similarity engine (reworked taxonomy) --------
    // Base partitions â€” keep simple: type, damage type (for spells/buildings), movement, towerOnly, role (tank/support/damage)
    const SPELLS = new Set(['Arrows','Zap','Snowball','Rage','Clone','Mirror','Fireball','Poison','Rocket','Lightning','Earthquake','Tornado','The Log','Barbarian Barrel','Royal Delivery','Heal Spirit']);
    const BUILDINGS = new Set(['X-Bow','Mortar','Cannon','Bomb Tower','Tesla','Inferno Tower','Furnace','Tombstone','Goblin Cage','Goblin Hut','Barbarian Hut','Elixir Collector','Goblin Drill']);

    // Damage type for spells
    const SPLASH_SPELLS = new Set(['Arrows','Fireball','Poison','Rocket','Lightning','Earthquake','Tornado','The Log','Royal Delivery','Barbarian Barrel','Snowball']);
    const SINGLE_SPELLS = new Set(['Zap','Rage','Clone','Mirror','Heal Spirit']); // functional/utility treated as single

    // Damage type for buildings
    const SPLASH_BUILDINGS = new Set(['Bomb Tower','Mortar']); // Mortar = area; Bomb Tower = splash
    const SINGLE_BUILDINGS = new Set(['Cannon','Tesla','Inferno Tower','X-Bow','Goblin Cage']);
    // Buildings with no direct damage
    const NON_DAMAGE_BUILDINGS = new Set(['Furnace','Tombstone','Goblin Hut','Barbarian Hut','Elixir Collector','Goblin Drill']);

    // Movement (troops)
    const AIR_TROOPS = new Set(['Minions','Minion Horde','Baby Dragon','Inferno Dragon','Electro Dragon','Skeleton Dragons','Phoenix','Mega Minion','Flying Machine','Lava Hound','Balloon']);
    // Troops that deploy >3 units at once â†’ swarm=true
    const SWARM_TROOPS = new Set(['Minion Horde','Bats','Barbarians','Royal Recruits','Royal Hogs','Goblin Gang','Skeleton Army']);

    // Obvious tower-only attackers (buildings-only targeting)
    const TOWER_ONLY = new Set(['Hog Rider','Giant','Goblin Giant','Royal Giant','Balloon','Battle Ram','Golem','Goblin Drill']);

    // Roles: primary (pick exactly one among tank/support/damage)
    const TANKS = new Set(['Giant','Goblin Giant','Royal Giant','Golem','Electro Giant','P.E.K.K.A','Mega Knight','Giant Skeleton','Lava Hound','Elixir Golem','Rune Giant']);
    const SUPPORT = new Set(['Ice Golem','Ice Wizard','Wizard','Electro Wizard','Magic Archer','Mother Witch','Fisherman','Battle Healer','Monk','Heal Spirit','Tornado','Rage','Mirror','Clone','Royal Delivery','Elixir Collector','Furnace','Goblin Hut','Barbarian Hut','Tombstone','Goblin Cage']);
    // Everything else defaults to damage

    // Helper maps for newer/custom cards (optional overrides)
    const CUSTOM_OVERRIDES = new Map([
      ['Spirit Empress', { role:'support' }],
      ['Berserker', { role:'damage' }],
      ['Goblin Curse', { type:'spell', dmg:'splash', role:'support' }],
      ['Goblin Machine', { type:'building', dmg:null, role:'support' }],
      ['Void', { type:'spell', dmg:'splash', role:'damage' }],
      ['Vines', { type:'spell', dmg:'single', role:'support' }],
      ['Goblin Demolisher', { role:'damage', towerOnly:true }],
      ['Suspicious Bush', { type:'building', dmg:null, role:'support' }],
      ['Rune Giant', { role:'tank', towerOnly:true }],
      ['Little Prince', { role:'damage' }],
      ['Goblinstein', { role:'tank' }]
    ]);

    function cardType(name){
      const o = CUSTOM_OVERRIDES.get(name); if(o?.type) return o.type;
      return SPELLS.has(name) ? 'spell' : (BUILDINGS.has(name) ? 'building' : 'troop');
    }

    function damageType(name){
      const o = CUSTOM_OVERRIDES.get(name); if(o?.dmg !== undefined) return o.dmg; // 'single'|'splash'|null
      const t = cardType(name);
      if(t==='spell') return SPLASH_SPELLS.has(name) ? 'splash' : (SINGLE_SPELLS.has(name) ? 'single' : null);
      if(t==='building'){
        if(NON_DAMAGE_BUILDINGS.has(name)) return null;
        if(SPLASH_BUILDINGS.has(name)) return 'splash';
        if(SINGLE_BUILDINGS.has(name)) return 'single';
        return null;
      }
      return null; // troops not required here
    }

    function movementType(name){
      const t = cardType(name);
      if(t==='building') return 'building';
      if(t==='troop') return AIR_TROOPS.has(name) ? 'air' : 'ground';
      return null; // spells
    }

    function isSwarm(name){
      return cardType(name)==='troop' && SWARM_TROOPS.has(name);
    }

    function isTowerOnly(name){
      const o = CUSTOM_OVERRIDES.get(name); if(o?.towerOnly !== undefined) return !!o.towerOnly;
      return TOWER_ONLY.has(name);
    }

    function primaryRole(name){
      const o = CUSTOM_OVERRIDES.get(name); if(o?.role) return o.role; // 'tank'|'support'|'damage'
      if(TANKS.has(name)) return 'tank';
      if(SUPPORT.has(name)) return 'support';
      return 'damage';
    }

    function meta(name){
      return {
        type: cardType(name),
        dmg: damageType(name),
        move: movementType(name),
        towerOnly: isTowerOnly(name),
        role: primaryRole(name),
        swarm: isSwarm(name)
      };
    }
    }

    function scoreMatch(base, cand){
      const A = meta(base), B = meta(cand);
      let s = 0;
      if(A.type && B.type && A.type===B.type) s += 4;                 // same type
      if(A.dmg && B.dmg && A.dmg===B.dmg) s += 2;                      // same damage style
      if(A.move && B.move && A.move===B.move) s += 2;                  // same movement
      if(A.towerOnly === B.towerOnly) s += 2;                          // same tower-only behavior
      if(A.role && B.role && A.role===B.role) s += 3;                  // same primary role
      if(A.swarm === B.swarm) s += 2;                                   // swarm alignment                  // same primary role
      return s;
    }

    function pickSimilar(base, difficulty='easy'){
      const candidates = CLASH_CARDS.filter(c => c !== base);
      const scored = candidates.map(c => ({ c, s: scoreMatch(base, c) }));
      const byScore = arr => arr.sort((a,b)=>b.s-a.s);

      // Easy: same type, best score
      if(difficulty==='easy'){
        const sameType = scored.filter(o => meta(o.c).type === meta(base).type);
        const pool = byScore(sameType);
        return (pool[0]?.c) || candidates[Math.floor(Math.random()*candidates.length)];
      }
      // Medium: same type + prefer same role/towerOnly
      if(difficulty==='medium'){
        const t = meta(base).type;
        const pool = byScore(scored.filter(o => meta(o.c).type===t))
          .sort((a,b)=>{
            const A = meta(a.c), B = meta(b.c), M = meta(base);
            const aBonus = (A.role===M.role) + (A.towerOnly===M.towerOnly);
            const bBonus = (B.role===M.role) + (B.towerOnly===M.towerOnly);
            return bBonus - aBonus;
          });
        return (pool[0]?.c) || candidates[Math.floor(Math.random()*candidates.length)];
      }
      // Hard: 40% same-type best, else best overall
      if(difficulty==='hard'){
        if(Math.random()<0.4){
          const sameType = byScore(scored.filter(o => meta(o.c).type===meta(base).type));
          return (sameType[0]?.c) || candidates[Math.floor(Math.random()*candidates.length)];
        }
        const all = byScore(scored);
        return all[0]?.c || candidates[Math.floor(Math.random()*candidates.length)];
      }
      // Chaos: random different card
      return candidates[Math.floor(Math.random()*candidates.length)];
    }

  </script>
</body>
</html>
