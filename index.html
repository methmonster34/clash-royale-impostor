<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="google-adsense-account" content="ca-pub-2021683559156386">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2021683559156386"
     crossorigin="anonymous"></script>
  <title>Clash Royale Imposter</title>
  <link rel="preconnect" href="https://raw.githubusercontent.com" />
  <style>
    :root { --bg:#0f172a; --panel:#0b1220; --text:#e5e7eb; --muted:#94a3b8; --accent:#22c55e; --danger:#ef4444; --primary:#0ea5e9; }
    *{box-sizing:border-box;font-family:system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif}
    body{margin:0;min-height:100vh;background:linear-gradient(180deg,#0a0f1c,#0f172a);color:var(--text);display:flex;align-items:center}
    .wrap{width:100%;max-width:760px;margin:0 auto;padding:20px}
    .card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:20px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    h1{margin:0 0 10px;font-size:28px}
    p.sub{margin:0 0 16px;color:var(--muted)}
    .modebar{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:10px}
    .modebtn{padding:10px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(56,189,248,.1);color:#c7f9ff;font-weight:700;cursor:pointer}
    .modebtn.primary{background:#38bdf8;color:#031d2c}
    .modebtn.disabled{opacity:.5;cursor:not-allowed}
    label{display:block;margin:8px 0 4px;color:var(--muted);font-size:14px}
    input, select{width:100%;padding:12px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0e1526;color:var(--text)}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .btn{width:100%;padding:14px 16px;border-radius:14px;border:1px solid rgba(255,255,255,.1);background:#152235;color:var(--text);font-weight:800;font-size:16px;cursor:pointer}
    .btn.primary{background:var(--primary);border-color:rgba(14,165,233,.5)}
    .btn.success{background:var(--accent);color:#052e16;border:none}
    .btn.danger{background:var(--danger);border:none}
    .center{display:flex;flex-direction:column;align-items:center;text-align:center;gap:14px}
    .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);font-size:12px;color:var(--muted)}
    .divider{height:1px;background:rgba(255,255,255,.08);margin:12px 0}
    .hidden{display:none}
    .wordStage{display:grid;grid-template-columns:1fr;gap:16px;width:100%}
    .wordCard{border-radius:24px;border:2px dashed rgba(255,255,255,.15);padding:16px 16px 20px;min-height:300px;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;gap:12px}
    .wordText{font-size:36px;font-weight:800;letter-spacing:.4px;text-align:center;word-break:break-word;max-width:100%}
    .imageSlot{width:100%;max-width:320px;aspect-ratio:1/1;display:flex;align-items:center;justify-content:center;border-radius:18px;border:1px dashed rgba(255,255,255,.14);background:rgba(255,255,255,.02)}
    #cardImg{max-width:100%;max-height:100%;object-fit:contain;display:none}
    .hint{color:var(--muted);font-size:14px;margin-top:-6px}

    /* Player/Impostor stepper */
    .stepper{display:flex;align-items:center;gap:10px}
    .stepBtn{width:44px;height:44px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0e1526;color:var(--text);font-weight:900;font-size:18px;cursor:pointer}
    .stepBtn:disabled{cursor:not-allowed;opacity:.6}
    .stepValue{flex:1;text-align:center;padding:12px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0e1526;color:var(--text);font-weight:800}
    .miniRow{display:flex;gap:10px;align-items:center;margin-top:8px}
    .tinyBtn{padding:8px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0e1526;color:var(--text);font-weight:800;cursor:pointer}
    .tinyBtn.on{background:rgba(34,197,94,.18);border-color:rgba(34,197,94,.5)}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="modebar">
      <button class="modebtn primary" id="modeClash" type="button">Clash Royale Imposter</button>
      <button class="modebtn" id="modeDark" type="button">Clash Royale in the Dark</button>
      <button class="modebtn" id="modeDarkWild" type="button">In the Dark (Wild)</button>
      <button class="modebtn" id="modeRandom" type="button">Random Mode</button>
    </div>

    <div class="card" id="screen-setup">
      <h1>Clash Royale Imposter</h1>
      <p class="sub">Pick a mode, set players/impostors, then start. In Dark modes, impostors get a similar card.</p>

      <div class="row">
        <div>
          <label>Players</label>
          <div class="stepper">
            <button class="stepBtn" id="playersMinus" type="button">−</button>
            <div class="stepValue" id="playersValue">4</div>
            <button class="stepBtn" id="playersPlus" type="button">+</button>
          </div>
        </div>

        <div>
          <label>Impostors (0 ≤ impostors ≤ players)</label>
          <div class="stepper">
            <button class="stepBtn" id="impostorsMinus" type="button">−</button>
            <div class="stepValue" id="impostorsValue">1</div>
            <button class="stepBtn" id="impostorsPlus" type="button">+</button>
          </div>

          <div class="miniRow">
            <button class="tinyBtn" id="toggleRandomImps" type="button">Random impostors: OFF</button>
          </div>
          <div class="hint" id="impHint" style="margin-top:6px">
            If Random is ON, impostor count is hidden and changes every round.
          </div>
        </div>
      </div>

      <div class="row" id="darkControls" style="margin-top:12px; display:none">
        <div>
          <label for="difficulty">Difficulty (Dark modes)</label>
          <select id="difficulty">
            <option value="easy">Easy (very similar)</option>
            <option value="medium" selected>Medium (mixed)</option>
            <option value="hard">Hard (deceptive)</option>
          </select>
        </div>
        <div></div>
      </div>

      <div class="row" style="margin-top:12px">
        <button class="btn primary" id="begin" type="button">Begin Round</button>
        <button class="btn danger" id="resetAllSetup" type="button">Reset</button>
      </div>
    </div>

    <div class="card hidden" id="screen-pass">
      <div class="center" style="width:100%">
        <div class="pill" id="turnInfo">Player 1 / ?</div>
        <div class="wordStage">
          <div class="wordCard">
            <div class="imageSlot">
              <img id="cardImg" alt="Card" />
            </div>
            <div class="wordText" id="wordText">Tap to reveal</div>
          </div>
          <div class="hint" id="hint">Hand the phone to this player before tapping.</div>
        </div>
        <button class="btn success" id="toggleBtn" type="button" style="width:100%">Reveal</button>
      </div>
    </div>

    <div class="card hidden" id="screen-summary">
      <div class="center">
        <div class="pill" id="roundInfoPill">Round finished</div>
        <h1>How to Play</h1>
        <p class="sub" style="max-width:640px" id="summaryText">
          Discuss clues without saying the card name. Figure out who the impostors are.
        </p>

        <button class="btn" id="showImpostors" type="button">Reveal Impostors</button>
        <div id="impostorList" class="sub hidden"></div>

        <div class="divider"></div>
        <button class="btn primary" id="playAgain" type="button">Play Again</button>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // 0) CONFIG
    // =========================
    const IMPOSTOR_IMAGE_URL = "";

    const RAW_BASE = "https://raw.githubusercontent.com/methmonster34/clash-royale-impostor/main";
    const IMAGE_FOLDERS = ["Clash Royale Imposter Images", "Clash Royale Imposter Images 2"];

    // =========================
    // 1) DATA
    // =========================
    const CLASH_CARDS = [
      'Arrows','Zap','Giant Snowball','Rage','Clone','Mirror','Heal Spirit','Fireball','Poison','Rocket','Lightning','Earthquake','Tornado','The Log','Barbarian Barrel','Royal Delivery','Freeze',
      'Skeletons','Ice Spirit','Fire Spirit','Bats','Spear Goblins','Goblins','Goblin Gang','Guards','Skeleton Army','Wall Breakers',
      'Archers','Knight','Bomber','Ice Golem','Minions','Minion Horde','Dart Goblin','Barbarians','Royal Recruits','Royal Hogs','Zappies','Rascals',
      'Musketeer','Hunter','Wizard','Ice Wizard','Electro Wizard','Magic Archer','Mother Witch',
      'Valkyrie','Mini P.E.K.K.A','Dark Prince','Prince','Bandit','Battle Ram','Cannon Cart','Ram Rider','Lumberjack','Battle Healer','Fisherman','Monk',
      'P.E.K.K.A','Giant','Giant Skeleton','Goblin Giant','Royal Giant','Hog Rider','Mega Knight','Sparky','Balloon',
      'X-Bow','Mortar','Cannon','Bomb Tower','Tesla','Inferno Tower','Furnace','Tombstone','Goblin Cage','Goblin Hut','Barbarian Hut','Elixir Collector','Goblin Drill',
      'Baby Dragon','Inferno Dragon','Electro Dragon','Skeleton Dragons','Phoenix',
      'Mega Minion','Flying Machine',
      'Golem','Lava Hound','Graveyard','Miner','Goblin Barrel','Elixir Golem','Electro Giant',
      'Three Musketeers',
      'Spirit Empress','Goblin Curse','Goblin Machine','Void','Vines','Goblin Demolisher','Suspicious Bush','Rune Giant','Little Prince','Goblinstein','Boss Bandit',
      'Archer Queen','Skeleton King','Golden Knight','Mighty Miner'
    ];

    // =========================
    // 2) HELPERS (DOM + Images)
    // =========================
    const el = id => document.getElementById(id);
    const screens = { setup: el("screen-setup"), pass: el("screen-pass"), summary: el("screen-summary") };
    const show = name => { Object.values(screens).forEach(s => s.classList.add("hidden")); screens[name].classList.remove("hidden"); };

    function shuffle(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function filenameForCard(name){ return name.toLowerCase().replace(/[^a-z0-9]/g,'') + '.png'; }

    function setCardImageByName(name){
      const img = el('cardImg');
      img.style.display = 'none';
      img.loading = 'eager';
      img.decoding = 'async';
      img.referrerPolicy = 'no-referrer';

      if(name === '__IMPOSTOR__' && IMPOSTOR_IMAGE_URL){
        img.onload = () => img.style.display = 'block';
        img.onerror = () => { img.removeAttribute('src'); img.style.display='none'; };
        img.src = IMPOSTOR_IMAGE_URL;
        return;
      }

      const file = filenameForCard(name);
      const urls = IMAGE_FOLDERS.map(folder => `${RAW_BASE}/${encodeURIComponent(folder)}/${file}`);
      let i = 0;

      function tryNext(){
        if(i >= urls.length){
          img.removeAttribute('src');
          img.style.display='none';
          return;
        }
        img.onerror = () => { i++; tryNext(); };
        img.onload  = () => { img.style.display = 'block'; };
        img.src = urls[i];
      }
      tryNext();
    }

    function prefetchCardImage(name){
      if(!name || name==='__IMPOSTOR__') return;
      const file = filenameForCard(name);
      IMAGE_FOLDERS.forEach(folder => {
        const i = new Image();
        i.decoding = 'async';
        i.referrerPolicy = 'no-referrer';
        i.src = `${RAW_BASE}/${encodeURIComponent(folder)}/${file}`;
      });
    }

    // =========================
    // 3) GAME STATE
    // =========================
    const state = {
      players: 4,
      impostors: 1,
      randomImpostors: false,

      selectedMode: 'clash',   // 'clash'|'dark'|'darkWild'|'random'
      roundMode: 'clash',

      difficulty: 'medium',    // 'easy'|'medium'|'hard'

      realCard: '',
      assignments: [],
      fakeCards: [],

      turn: 0,
      revealed: false,
      history: [],

      lastReal: null,
      lastFakes: new Set()
    };

    // =========================
    // 4) SETUP UI LOGIC
    // =========================
    function setMode(newMode){
      state.selectedMode = newMode;

      el('modeClash').classList.toggle('primary', newMode==='clash');
      el('modeDark').classList.toggle('primary', newMode==='dark');
      el('modeDarkWild').classList.toggle('primary', newMode==='darkWild');
      el('modeRandom').classList.toggle('primary', newMode==='random');

      const showDarkControls = (newMode === 'dark' || newMode === 'darkWild' || newMode === 'random');
      el('darkControls').style.display = showDarkControls ? 'grid' : 'none';
    }

    function setImpostors(n){
      state.impostors = Math.max(0, Math.min(state.players, n));
      el('impostorsValue').textContent = state.randomImpostors ? '?' : String(state.impostors);
    }

    function setPlayers(n){
      state.players = Math.max(3, Math.min(20, n));
      el('playersValue').textContent = String(state.players);
      setImpostors(state.impostors); // clamp + refresh
    }

    function readSetup(){
      state.difficulty = el('difficulty').value || 'medium';
    }

    function setRandomImpostors(on){
      state.randomImpostors = !!on;
      el('toggleRandomImps').classList.toggle('on', state.randomImpostors);
      el('toggleRandomImps').textContent = state.randomImpostors ? 'Random impostors: ON' : 'Random impostors: OFF';

      el('impostorsMinus').disabled = state.randomImpostors;
      el('impostorsPlus').disabled  = state.randomImpostors;

      el('impostorsValue').textContent = state.randomImpostors ? '?' : String(state.impostors);
    }

    function resetSetup(){
      setPlayers(4);
      setImpostors(1);
      setRandomImpostors(false);
      el('difficulty').value = 'medium';
      setMode('clash');
    }

    // =========================
    // 5) ROUND MODE CHOICE
    // =========================
    function chooseRoundMode(){
      if(state.selectedMode !== 'random') return state.selectedMode;
      const modes = ['clash','dark','darkWild'];
      return modes[Math.floor(Math.random()*modes.length)];
    }

    function chooseImpostorCount(players){
      if(!state.randomImpostors) return Math.max(0, Math.min(players, state.impostors));

      if(players <= 0) return 0;
      if(players === 1) return Math.random() < 0.5 ? 0 : 1;

      const r = Math.random();
      if(r < 0.10) return 0;
      if(r > 0.90) return players;

      return 1 + Math.floor(Math.random() * (players - 1));
    }

    // =========================
    // 6) CARD META + SIMILARITY ENGINE (ANCHOR ENFORCED)
    // =========================
    const SPELLS = new Set([
      'Arrows','Zap','Giant Snowball','Royal Delivery','Fireball','Rocket','Earthquake','Rage',
      'Goblin Barrel','Freeze','Mirror','Lightning','Poison','Tornado','Clone','Barbarian Barrel',
      'Void','Goblin Curse','Vines','Graveyard','The Log','Heal Spirit'
    ]);

    const BUILDINGS = new Set([
      'Cannon','Mortar','Tesla','Goblin Hut','Inferno Tower','Bomb Tower','Barbarian Hut',
      'Elixir Collector','Tombstone','Furnace','Goblin Cage','X-Bow','Goblin Drill'
    ]);

    const AIR_TROOPS = new Set([
      'Minions','Minion Horde','Bats','Baby Dragon','Inferno Dragon','Electro Dragon',
      'Skeleton Dragons','Phoenix','Mega Minion','Flying Machine','Lava Hound','Balloon'
    ]);

    const WINCONS = new Set(['Hog Rider','Balloon','Giant','Golem','Lava Hound','Goblin Giant','Royal Giant','Miner','Graveyard','Goblin Barrel','Goblin Drill','Battle Ram','Ram Rider','X-Bow','Mortar','Elixir Golem','Electro Giant','Three Musketeers']);
    const TANKS = new Set(['Giant','Golem','Lava Hound','Royal Giant','Goblin Giant','Electro Giant','P.E.K.K.A','Mega Knight','Giant Skeleton','Elixir Golem','Rune Giant']);
    const CONTROL = new Set(['Tornado','Freeze','Ice Wizard','Electro Wizard','Zappies','Lightning','Fisherman','Monk','Vines','Earthquake','Poison','The Log','Giant Snowball','Zap']);
    const SPAWNERS = new Set(['Tombstone','Goblin Hut','Barbarian Hut','Furnace','Goblin Drill','Goblin Cage','Graveyard','Royal Delivery','Mother Witch','Goblin Curse']);
    const SIEGE = new Set(['X-Bow','Mortar']);
    const ECONOMY = new Set(['Elixir Collector']);

    // ✅ UPDATED hints (includes Guards are skeletons, plus pump/economy, pierce, etc.)
    const FAMILY_HINTS = new Map([
      ['Goblin Hut', ['goblin','spawner']],
      ['Goblin Cage', ['goblin']],
      ['Goblin Drill', ['goblin']],
      ['Goblin Barrel', ['goblin']],
      ['Goblin Curse', ['goblin','curse']],
      ['Tombstone', ['skeleton','spawner']],
      ['Graveyard', ['skeleton','spawner']],
      ['Furnace', ['fire','spirit','spawner']],
      ['Royal Delivery', ['royal','recruit','spawner']],
      ['Barbarian Barrel', ['barbarian','roll','spawner']],
      ['Barbarian Hut', ['barbarian','spawner']],
      ['Inferno Tower', ['inferno','fire']],
      ['Inferno Dragon', ['inferno','fire','dragon']],
      ['Electro Dragon', ['electro','dragon']],
      ['Tesla', ['electro']],
      ['Zap', ['electro']],
      ['Lightning', ['electro']],
      ['Freeze', ['ice']],
      ['Giant Snowball', ['ice']],
      ['Ice Spirit', ['ice','spirit']],
      ['Fire Spirit', ['fire','spirit']],
      ['Poison', ['poison']],
      ['Void', ['dark']],
      ['Rage', ['rage','buff']],
      ['The Log', ['log','knockback']],

      // NEW anchors to prevent trash matches
      ['Guards', ['skeleton','shield']],
      ['Bomber', ['skeleton','bomb','splash']],
      ['Wizard', ['wizard','mage','splash']],
      ['Magic Archer', ['archer','magic','pierce']],
      ['Miner', ['burrow','miner']],
      ['Battle Ram', ['ram','dash']],
      ['Elixir Collector', ['pump','economy']],
    ]);

    const OVERRIDE_TAGS = {
      'Mother Witch': { visuals:['granny','blue eyes','purple','pink'], families:['witch','curse','hog'], mechanics:['curse','transform','spawn'] },
      'Phoenix': { visuals:['phoenix','fire bird','egg'], families:['phoenix','fire'], mechanics:['revive','egg','death_damage'] },
      'Goblin Machine': { visuals:['baby goblin','goggles','machine','rocket'], families:['goblin','machine'], mechanics:['rocket','hybrid'] },
      'Spirit Empress': { visuals:['gold armor','blonde','blue dragon','two forms'], families:['spirit','royal','dragon'], mechanics:['dual_form','air_ground'] },
      'Mighty Miner': { visuals:['orange mustache','helmet','drill'], families:['miner','machine'], mechanics:['ramp_damage','lane_swap','bomb'] },
      'Skeleton King': { visuals:['crown','spiked club'], families:['skeleton','royal'], mechanics:['soul','summon'] },
      'Archer Queen': { visuals:['purple hair','crown','cape'], families:['royal','archer'], mechanics:['cloak','speed_boost'] },
      'Golden Knight': { visuals:['gold armor','gold hair','blue eyes'], families:['royal','knight'], mechanics:['dash_chain'] },
      'Monk': { visuals:['bald','beads','white beard','reflect'], families:['monk'], mechanics:['reflect','combo','pushback'] },
      'Little Prince': { visuals:['kid','crown','crossbow','guardian'], families:['royal','prince'], mechanics:['ramp_speed','summon_guardian'] },
      'Goblinstein': { visuals:['scientist goblin','big monster','electric link'], families:['goblin','electro'], mechanics:['stun','dual_unit','ability'] },
      'Boss Bandit': { visuals:['red hair','cape','covered face'], families:['bandit'], mechanics:['dash','invis','teleport','grenades'] }
    };

    function cardType(name){
      if(SPELLS.has(name)) return 'spell';
      if(BUILDINGS.has(name)) return 'building';
      return 'troop';
    }

    function movement(name){
      const t = cardType(name);
      if(t === 'building') return 'static';
      if(t === 'spell') return 'spell';
      return AIR_TROOPS.has(name) ? 'air' : 'ground';
    }

    function baseRoles(name){
      const roles = [];
      if(WINCONS.has(name)) roles.push('wincon');
      if(TANKS.has(name)) roles.push('tank');
      if(CONTROL.has(name)) roles.push('control');
      if(SPAWNERS.has(name)) roles.push('spawner');
      if(SIEGE.has(name)) roles.push('siege');
      if(ECONOMY.has(name)) roles.push('economy');

      if(roles.length === 0){
        const t = cardType(name);
        if(t === 'spell') roles.push('spell');
        else if(t === 'building') roles.push('defense');
        else roles.push('dps');
      }
      return roles;
    }

    function primaryRole(roles){
      const order = ['wincon','tank','siege','control','spawner','economy','dps','defense','spell'];
      for(const r of order) if(roles.includes(r)) return r;
      return roles[0] || 'dps';
    }

    function normName(name){
      return name
        .toLowerCase()
        .replace(/p\.?e\.?k\.?k\.?a/g, 'pekka')
        .replace(/x-?bow/g, 'xbow')
        .replace(/[^a-z0-9 ]/g,' ')
        .replace(/\s+/g,' ')
        .trim();
    }

    function tokenSet(name){
      const n = normName(name);
      const set = new Set(n.split(' ').filter(Boolean));
      if(set.has('electro')) set.add('electric');
      if(set.has('goblin')) set.add('green');
      if(set.has('skeleton')) set.add('undead');
      return set;
    }

    function bigramSet(str){
      const s = str.replace(/\s+/g,'');
      const out = new Set();
      for(let i=0;i<s.length-1;i++) out.add(s.slice(i,i+2));
      return out;
    }

    function jaccard(A, B){
      if(A.size === 0 && B.size === 0) return 0;
      let inter = 0;
      for(const x of A) if(B.has(x)) inter++;
      const union = A.size + B.size - inter;
      return union ? (inter / union) : 0;
    }

    function nameSim(aName, bName){
      const A = bigramSet(normName(aName));
      const B = bigramSet(normName(bName));
      return jaccard(A, B);
    }

    function addHintsFromMaps(name, families, mechanics, visuals){
      const hints = FAMILY_HINTS.get(name);
      if(hints){
        for(const h of hints){
          families.add(h);
          if(h === 'roll') mechanics.add('roll');
          if(h === 'knockback') mechanics.add('knockback');
          if(h === 'buff') mechanics.add('buff');
        }
      }
      const o = OVERRIDE_TAGS[name];
      if(o?.families) o.families.forEach(x => families.add(x));
      if(o?.mechanics) o.mechanics.forEach(x => mechanics.add(x));
      if(o?.visuals) o.visuals.forEach(x => visuals.add(x));
    }

    function inferElement(families, mechanics, tokens, visuals){
      const preferred = ['electro','ice','fire','poison','dark','spirit','inferno'];
      for(const e of preferred){
        if(families.has(e) || mechanics.has(e) || tokens.has(e) || visuals.has(e) || tokens.has(e === 'electro' ? 'electric' : e)) return e;
      }
      return null;
    }

    function inferSilhouette(type, move, families, roles, tokens){
      if(type === 'spell') return 'spell';
      if(type === 'building') return 'building';
      if(families.has('dragon') || tokens.has('dragon')) return 'dragon';
      if(families.has('skeleton') || tokens.has('skeleton') || families.has('undead')) return 'undead';
      if(families.has('goblin') || tokens.has('goblin')) return 'goblin';
      if(roles.includes('tank')) return 'big';
      if(roles.includes('spawner')) return 'spawner';
      if(move === 'air') return 'flying';
      return 'humanoid';
    }

    const CARD_DB = new Map();
    const SIM_CACHE = new Map();

    function buildCardDB(){
      CARD_DB.clear();
      SIM_CACHE.clear();

      for(const name of CLASH_CARDS){
        const type = cardType(name);
        const move = movement(name);
        const roles = baseRoles(name);
        const tokens = tokenSet(name);

        const families = new Set([...tokens]);
        const mechanics = new Set();
        const visuals = new Set();

        if(tokens.has('freeze')) mechanics.add('freeze');
        if(tokens.has('tornado')) mechanics.add('pull');
        if(tokens.has('zap') || tokens.has('electro') || tokens.has('lightning') || tokens.has('tesla')) mechanics.add('stun');
        if(tokens.has('poison')) mechanics.add('dot');
        if(tokens.has('rage')) mechanics.add('buff');
        if(tokens.has('clone') || tokens.has('mirror')) mechanics.add('copy');
        if(tokens.has('log') || tokens.has('snowball')) mechanics.add('knockback');
        if(tokens.has('barrel')) mechanics.add('roll');
        if(tokens.has('drill') || tokens.has('miner')) mechanics.add('burrow');
        if(tokens.has('bandit') || tokens.has('prince') || tokens.has('ram')) mechanics.add('dash');

        if(SPAWNERS.has(name)) mechanics.add('spawn');
        if(name === 'Inferno Tower' || name === 'Inferno Dragon') mechanics.add('ramp');
        if(name === 'Phoenix') mechanics.add('revive');

        if(tokens.has('ice') || tokens.has('snow')) visuals.add('blue');
        if(tokens.has('fire') || tokens.has('inferno') || tokens.has('phoenix')) visuals.add('fire');
        if(tokens.has('electro') || tokens.has('zap') || tokens.has('lightning') || tokens.has('tesla')) visuals.add('electric');
        if(tokens.has('goblin')) visuals.add('green');
        if(tokens.has('skeleton') || tokens.has('grave')) visuals.add('undead');
        if(tokens.has('royal') || tokens.has('king') || tokens.has('queen') || tokens.has('prince') || tokens.has('knight')) visuals.add('crown');

        addHintsFromMaps(name, families, mechanics, visuals);

        const element = inferElement(families, mechanics, tokens, visuals);
        const silhouette = inferSilhouette(type, move, families, roles, tokens);

        CARD_DB.set(name, {
          name, type, move,
          roles,
          primary: primaryRole(roles),
          tokens: [...tokens],
          families: [...families],
          mechanics: [...mechanics],
          visuals: [...visuals],
          element,
          silhouette
        });
      }
    }

    function overlapCount(aArr, bArr){
      const B = new Set(bArr);
      let c = 0;
      for(const x of aArr) if(B.has(x)) c++;
      return c;
    }

    // ✅ shared sets (avoid recreating every call)
    const GENERIC_PRIMARY = new Set(['dps','defense','spell']);
    const GENERIC_SIL = new Set(['humanoid','building','spell']);

    // =========================
    // NEW coreMatchCount (no generic inflation)
    // =========================
    function coreMatchCount(A, B, ns){
      let core = 0;

      if(A.element && A.element === B.element) core++;
      if(overlapCount(A.families, B.families) >= 1) core++;
      if(overlapCount(A.mechanics, B.mechanics) >= 1) core++;
      if(ns >= 0.30) core++;

      if(!GENERIC_PRIMARY.has(A.primary) && A.primary === B.primary) core++;
      if(!GENERIC_SIL.has(A.silhouette) && A.silhouette === B.silhouette) core++;

      return core;
    }

   // updated similarity algorithm for dark mode
// priority order: (1) element + physical attributes, (2) name similarity, (3) mechanics/families/roles


const GENERIC_PRIMARY = new Set(['dps','defense','spell']);
const GENERIC_SIL = new Set(['humanoid','building','spell']);


function coreMatchCount(A, B, ns) {
const elementMatch = (A.element && A.element === B.element);
const typeMatch = (A.type === B.type);
const moveMatch = (A.move === B.move);
const silMatch = (!GENERIC_SIL.has(A.silhouette) && A.silhouette === B.silhouette);


const visOv = overlapCount(A.visuals, B.visuals);
const mecOv = overlapCount(A.mechanics, B.mechanics);


let core = 0;
if (elementMatch) core += 2; // element is strongest
if (typeMatch) core += 1; // troop/building/spell must align
if (moveMatch) core += 1; // air/ground/static/spell
if (silMatch) core += 1; // dragon/goblin/undead/etc.
if (visOv >= 2) core += 1; // physical look overlap


// name comes next
if (ns >= 0.34) core += 1;


// still useful, but lower priority
if (mecOv >= 1) core += 1;


return core;
}


function similarityScore(real, cand){
const A = CARD_DB.get(real);
const B = CARD_DB.get(cand);
if(!A || !B || real === cand) return -Infinity;


const ns = nameSim(real, cand);
const famOv = overlapCount(A.families, B.families);
const mecOv = overlapCount(A.mechanics, B.mechanics);
const roleOv = overlapCount(A.roles, B.roles);
const visOv = overlapCount(A.visuals, B.visuals);


const elementMatch = (A.element && A.element === B.element);
const typeMatch = (A.type === B.type);
const moveMatch = (A.move === B.move);
if(!typeMatch) return -Infinity; // physical type is mandatory


const roleMatch = (!GENERIC_PRIMARY.has(A.primary) && A.primary === B.primary);
const silMatch = (!GENERIC_SIL.has(A.silhouette) && A.silhouette === B.silhouette);


// must share element OR strong physical similarity OR strong name OR at least 1 mechanic overlap
const physStrong = (moveMatch ? 1 : 0) + (silMatch ? 1 : 0) + (visOv >= 2 ? 1 : 0);
const hasAnchor = elementMatch || physStrong >= 2 || mecOv >= 1 || ns >= 0.42;
if(!hasAnchor) return -Infinity;


let s = 0;


// (1) element + physical attributes (MOST IMPORTANT)
s += elementMatch ? 34 : 0;
s += moveMatch ? 12 : 0;
s += silMatch ? 18 : 0;
s += Math.min(24, visOv * 6);


// (2) name similarity (SECOND)
s += ns * 14;


// (3) mechanics / families / roles (SUPPORTING)
s += Math.min(10, mecOv * 5);
s += Math.min(8, famOv * 2);
s += Math.min(4, roleOv * 1);
s += roleMatch ? 3 : 0;


return { score: s, ns };
}
        // ✅ thresholds adjusted for the new core definition
        if(difficulty === 'easy'){
          if(core < 3) continue;
          if(s < 20) continue;
        } else if(difficulty === 'medium'){
          if(core < 2) continue;
          if(s < 14) continue;
        } else {
          if(core < 2) continue;
          s += hardDeceptionBonus(A, B, base.ns, famOv);
        }

        out.push({ c, s });
      }

      out.sort((a,b)=>b.s-a.s);

      let pool;
      if(difficulty === 'easy') pool = out.slice(0, 18);
      else if(difficulty === 'medium') pool = out.slice(0, 30);
      else pool = out.slice(0, 38);

      if(pool.length < 10){
        const fallback = [];
        for(const c of CLASH_CARDS){
          if(c === real) continue;
          const base = similarityScore(real, c);
          if(base === -Infinity) continue;
          const A = CARD_DB.get(real), B = CARD_DB.get(c);
          const core = coreMatchCount(A, B, base.ns);
          if(core >= 1) fallback.push({ c, s: base.score }); // loosened fallback
        }
        fallback.sort((a,b)=>b.s-a.s);
        pool = fallback.slice(0, difficulty === 'easy' ? 16 : (difficulty === 'medium' ? 26 : 34));
      }

      SIM_CACHE.set(key, pool);
      return pool;
    }

    function pickFakeCard(real, difficulty, avoidSet = new Set()){
      const ranked = rankedCandidates(real, difficulty);
      const pool = ranked.map(x => x.c);

      const filtered = pool.filter(c => c !== real && !avoidSet.has(c));
      const use = filtered.length ? filtered : pool.filter(c => c !== real);

      if(!use.length){
        let c = real;
        for(let t=0;t<10 && c===real;t++){
          c = CLASH_CARDS[Math.floor(Math.random()*CLASH_CARDS.length)];
        }
        return c === real ? (CLASH_CARDS.find(x=>x!==real) || real) : c;
      }

      const topN = (difficulty === 'easy') ? 6 : (difficulty === 'medium' ? 10 : 14);
      const slice = use.slice(0, Math.min(topN, use.length));
      return slice[Math.floor(Math.random()*slice.length)];
    }

    // =========================
    // 7) ROUND GENERATION
    // =========================
    function pickRealCard(){
      let pick = null;
      for(let tries=0; tries<6; tries++){
        const c = CLASH_CARDS[Math.floor(Math.random()*CLASH_CARDS.length)];
        if(c !== state.lastReal){
          pick = c;
          break;
        }
        pick = c;
      }
      return pick;
    }

    function assignRoles(impostorCount){
      const roles = Array(state.players).fill('REAL');
      const idx = shuffle([...Array(state.players)].map((_,i)=>i));
      for(let i=0;i<impostorCount;i++){
        roles[idx[i]] = 'IMPOSTOR';
      }
      state.assignments = roles;
    }

    function assignFakeCardsForDarkModes(){
      state.fakeCards = Array(state.players).fill(null);
      const avoid = new Set(state.lastFakes);

      if(state.roundMode === 'dark'){
        const fake = pickFakeCard(state.realCard, state.difficulty, avoid);
        for(let i=0;i<state.players;i++){
          if(state.assignments[i] === 'IMPOSTOR') state.fakeCards[i] = fake;
        }
        prefetchCardImage(fake);
        return;
      }

      if(state.roundMode === 'darkWild'){
        const used = new Set();
        for(let i=0;i<state.players;i++){
          if(state.assignments[i] !== 'IMPOSTOR') continue;

          const localAvoid = new Set([...avoid, ...used]);
          let fake = pickFakeCard(state.realCard, state.difficulty, localAvoid);

          if(used.has(fake)){
            const pool = rankedCandidates(state.realCard, state.difficulty).map(x=>x.c);
            for(const candidate of pool){
              if(candidate !== state.realCard && !used.has(candidate) && !avoid.has(candidate)){
                fake = candidate; break;
              }
            }
          }

          state.fakeCards[i] = fake;
          used.add(fake);
          prefetchCardImage(fake);
        }
      }
    }

    function beginRound(){
      readSetup();

      state.roundMode = chooseRoundMode();
      const impCount = chooseImpostorCount(state.players);

      state.realCard = pickRealCard();
      prefetchCardImage(state.realCard);

      assignRoles(impCount);

      if(state.roundMode === 'dark' || state.roundMode === 'darkWild'){
        assignFakeCardsForDarkModes();
      } else {
        state.fakeCards = Array(state.players).fill(null);
      }

      state.turn = 0;
      state.revealed = false;
      state.history = [];

      state.lastReal = state.realCard;
      state.lastFakes = new Set(state.fakeCards.filter(Boolean));

      show('pass');
      updatePassUI();
    }

    // =========================
    // 8) PASS SCREEN RENDERING
    // =========================
    function modeLabel(m){
      if(m==='clash') return 'Clash Royale Impostor';
      if(m==='dark') return 'In the Dark';
      if(m==='darkWild') return 'In the Dark (Wild)';
      return 'Random Mode';
    }

    function cardForCurrentPlayer(){
      const role = state.assignments[state.turn];
      const isImp = role === 'IMPOSTOR';

      if(state.roundMode === 'clash'){
        if(isImp) return { text:'IMPOSTOR', color:'var(--danger)', img:'__IMPOSTOR__' };
        return { text:state.realCard, color:'var(--text)', img:state.realCard };
      }

      if(isImp){
        const fake = state.fakeCards[state.turn] || state.realCard;
        return { text:fake, color:'var(--text)', img:fake };
      }
      return { text:state.realCard, color:'var(--text)', img:state.realCard };
    }

    function updatePassUI(){
      el('turnInfo').textContent = `Player ${state.turn+1} / ${state.players}`;

      const img = el('cardImg');
      if(!state.revealed){
        el('wordText').textContent = 'Tap to reveal';
        el('wordText').style.color = 'var(--text)';
        el('hint').textContent = 'Hand the phone to this player before tapping.';
        el('toggleBtn').textContent = 'Reveal';
        img.removeAttribute('src');
        img.style.display = 'none';
        return;
      }

      const info = cardForCurrentPlayer();
      el('wordText').textContent = info.text;
      el('wordText').style.color = info.color;

      if(state.roundMode === 'clash' && info.text === 'IMPOSTOR' && !IMPOSTOR_IMAGE_URL){
        img.removeAttribute('src');
        img.style.display='none';
      } else {
        setCardImageByName(info.img);
      }

      if(state.turn === state.players-1){
        el('hint').textContent = 'Last player revealed. Tap again to finish.';
        el('toggleBtn').textContent = 'Finish Round';
      } else {
        el('hint').textContent = (state.roundMode === 'clash')
          ? 'Tap Next Player and pass the phone.'
          : 'Don’t say the card name. Describe it vaguely, then pass the phone.';
        el('toggleBtn').textContent = 'Next Player';
      }
    }

    function nextTurn(){
      state.history.push({ player: state.turn+1, role: state.assignments[state.turn], shown: cardForCurrentPlayer().text });
      state.turn++;
      state.revealed = false;

      if(state.turn >= state.players){
        showSummary();
        return;
      }
      updatePassUI();
    }

    function showSummary(){
      show('summary');

      const impPlayers = state.history.filter(h => h.role === 'IMPOSTOR').map(h => `Player ${h.player}`);
      const impCount = impPlayers.length;

      el('roundInfoPill').textContent = `${modeLabel(state.roundMode)} • Real card: ${state.realCard}`;

      if(state.roundMode === 'clash'){
        el('summaryText').innerHTML =
          `Most players saw <b>${state.realCard}</b>. Impostors saw <b style="color:var(--danger)">IMPOSTOR</b>. Discuss clues without saying the name.`;
      } else {
        const uniqueFakes = [...new Set(state.fakeCards.filter(Boolean))];
        const fakesText = uniqueFakes.length ? uniqueFakes.join(', ') : '(none)';
        el('summaryText').innerHTML =
          `Most players saw <b>${state.realCard}</b>. Impostors saw a <b>similar</b> card instead. Difficulty: <b>${state.difficulty}</b>.<br/><span style="color:var(--muted)">Fake card(s) used this round: ${fakesText}</span>`;
      }

      el('impostorList').classList.add('hidden');
      el('impostorList').textContent = impCount ? `Impostors: ${impPlayers.join(', ')}` : 'Impostors: none';
    }

    // =========================
    // 9) EVENTS
    // =========================
    el('modeClash').onclick = () => setMode('clash');
    el('modeDark').onclick = () => setMode('dark');
    el('modeDarkWild').onclick = () => setMode('darkWild');
    el('modeRandom').onclick = () => setMode('random');

    el('playersMinus').onclick = () => setPlayers(state.players - 1);
    el('playersPlus').onclick  = () => setPlayers(state.players + 1);

    el('impostorsMinus').onclick = () => { if(!state.randomImpostors) setImpostors(state.impostors - 1); };
    el('impostorsPlus').onclick  = () => { if(!state.randomImpostors) setImpostors(state.impostors + 1); };

    el('toggleRandomImps').onclick = () => setRandomImpostors(!state.randomImpostors);

    el('begin').onclick = () => beginRound();
    el('resetAllSetup').onclick = () => resetSetup();

    el('toggleBtn').onclick = () => {
      if(!state.revealed){
        state.revealed = true;
        updatePassUI();
      } else {
        nextTurn();
      }
    };

    el('showImpostors').onclick = () => {
      el('impostorList').classList.remove('hidden');
    };

    el('playAgain').onclick = () => show('setup');

    // =========================
    // 10) INIT
    // =========================
    buildCardDB();
    resetSetup();
  </script>
</body>
</html>
