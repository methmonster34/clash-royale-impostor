<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Clash Royale Imposter</title>
  <link rel="preconnect" href="https://raw.githubusercontent.com" />
  <style>
    :root { --bg:#0f172a; --panel:#0b1220; --text:#e5e7eb; --muted:#94a3b8; --accent:#22c55e; --danger:#ef4444; --primary:#0ea5e9; }
    *{box-sizing:border-box;font-family:system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif}
    body{margin:0;min-height:100vh;background:linear-gradient(180deg,#0a0f1c,#0f172a);color:var(--text);display:flex;align-items:center}
    .wrap{width:100%;max-width:760px;margin:0 auto;padding:20px}
    .card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:20px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    h1{margin:0 0 10px;font-size:28px}
    p.sub{margin:0 0 16px;color:var(--muted)}
    .modebar{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:10px}
    .modebtn{padding:10px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(56,189,248,.1);color:#c7f9ff;font-weight:700;cursor:pointer}
    .modebtn.primary{background:#38bdf8;color:#031d2c}
    .modebtn.disabled{opacity:.5;cursor:not-allowed}
    label{display:block;margin:8px 0 4px;color:var(--muted);font-size:14px}
    input, select{width:100%;padding:12px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0e1526;color:var(--text)}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .btn{width:100%;padding:14px 16px;border-radius:14px;border:1px solid rgba(255,255,255,.1);background:#152235;color:var(--text);font-weight:800;font-size:16px;cursor:pointer}
    .btn.primary{background:var(--primary);border-color:rgba(14,165,233,.5)}
    .btn.success{background:var(--accent);color:#052e16;border:none}
    .btn.danger{background:var(--danger);border:none}
    .center{display:flex;flex-direction:column;align-items:center;text-align:center;gap:14px}
    .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);font-size:12px;color:var(--muted)}
    .divider{height:1px;background:rgba(255,255,255,.08);margin:12px 0}
    .hidden{display:none}
    .wordStage{display:grid;grid-template-columns:1fr;gap:16px;width:100%}
    .wordCard{border-radius:24px;border:2px dashed rgba(255,255,255,.15);padding:16px 16px 20px;min-height:300px;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;gap:12px}
    .wordText{font-size:36px;font-weight:800;letter-spacing:.4px;text-align:center;word-break:break-word;max-width:100%}
    .imageSlot{width:100%;max-width:320px;aspect-ratio:1/1;display:flex;align-items:center;justify-content:center;border-radius:18px;border:1px dashed rgba(255,255,255,.14);background:rgba(255,255,255,.02)}
    #cardImg{max-width:100%;max-height:100%;object-fit:contain;display:none}
    .hint{color:var(--muted);font-size:14px;margin-top:-6px}

    /* Player stepper (minimal UI addition) */
    .stepper{display:flex;align-items:center;gap:10px}
    .stepBtn{width:44px;height:44px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0e1526;color:var(--text);font-weight:900;font-size:18px;cursor:pointer}
    .stepValue{flex:1;text-align:center;padding:12px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0e1526;color:var(--text);font-weight:800}
    .miniRow{display:flex;gap:10px;align-items:center;margin-top:8px}
    .tinyBtn{padding:8px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0e1526;color:var(--text);font-weight:800;cursor:pointer}
    .tinyBtn.on{background:rgba(34,197,94,.18);border-color:rgba(34,197,94,.5)}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="modebar">
      <button class="modebtn primary" id="modeClash" type="button">Clash Royale Imposter</button>
      <button class="modebtn" id="modeDark" type="button">Clash Royale in the Dark</button>
      <button class="modebtn" id="modeDarkWild" type="button">In the Dark (Wild)</button>
      <button class="modebtn" id="modeRandom" type="button">Random Mode</button>
    </div>

    <div class="card" id="screen-setup">
      <h1>Clash Royale Imposter</h1>
      <p class="sub">Pick a mode, set players/impostors, then start. In Dark modes, impostors get a similar card.</p>

      <div class="row">
        <div>
          <label>Players</label>
          <div class="stepper">
            <button class="stepBtn" id="playersMinus" type="button">−</button>
            <div class="stepValue" id="playersValue">4</div>
            <button class="stepBtn" id="playersPlus" type="button">+</button>
          </div>
        </div>

        <div>
          <label for="impostors">Impostors (0 ≤ impostors ≤ players)</label>
          <input id="impostors" type="number" min="0" value="1" />
          <div class="miniRow">
            <button class="tinyBtn" id="toggleRandomImps" type="button">Random impostors: OFF</button>
          </div>
          <div class="hint" id="impHint" style="margin-top:6px">If Random is ON, impostor count is hidden and changes every round.</div>
        </div>
      </div>

      <div class="row" id="darkControls" style="margin-top:12px; display:none">
        <div>
          <label for="difficulty">Difficulty (Dark modes)</label>
          <select id="difficulty">
            <option value="easy">Easy (very similar)</option>
            <option value="medium" selected>Medium (mixed)</option>
            <option value="hard">Hard (deceptive)</option>
          </select>
        </div>
        <div></div>
      </div>

      <div class="row" style="margin-top:12px">
        <button class="btn primary" id="begin" type="button">Begin Round</button>
        <button class="btn danger" id="resetAllSetup" type="button">Reset</button>
      </div>
    </div>

    <div class="card hidden" id="screen-pass">
      <div class="center" style="width:100%">
        <div class="pill" id="turnInfo">Player 1 / ?</div>
        <div class="wordStage">
          <div class="wordCard">
            <div class="imageSlot">
              <img id="cardImg" alt="Card" />
            </div>
            <div class="wordText" id="wordText">Tap to reveal</div>
          </div>
          <div class="hint" id="hint">Hand the phone to this player before tapping.</div>
        </div>
        <button class="btn success" id="toggleBtn" type="button" style="width:100%">Reveal</button>
      </div>
    </div>

    <div class="card hidden" id="screen-summary">
      <div class="center">
        <div class="pill" id="roundInfoPill">Round finished</div>
        <h1>How to Play</h1>
        <p class="sub" style="max-width:640px" id="summaryText">
          Discuss clues without saying the card name. Figure out who the impostors are.
        </p>

        <button class="btn" id="showImpostors" type="button">Reveal Impostors</button>
        <div id="impostorList" class="sub hidden"></div>

        <div class="divider"></div>
        <button class="btn primary" id="playAgain" type="button">Play Again</button>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // 0) CONFIG
    // =========================
    // If you want an impostor image in Normal mode, set this to a direct image URL.
    // Example: const IMPOSTOR_IMAGE_URL = "https://yourdomain.com/impostor.png";
    const IMPOSTOR_IMAGE_URL = "";

    // Card image repo (your existing setup)
    const RAW_BASE = "https://raw.githubusercontent.com/methmonster34/clash-royale-impostor/main";
    const IMAGE_FOLDERS = ["Clash Royale Imposter Images", "Clash Royale Imposter Images 2"];

    // =========================
    // 1) DATA (card list)
    // =========================
    // Keep your master list here. (You said this is all cards in your game.)
    const CLASH_CARDS = [
      'Arrows','Zap','Giant Snowball','Rage','Clone','Mirror','Heal Spirit','Fireball','Poison','Rocket','Lightning','Earthquake','Tornado','The Log','Barbarian Barrel','Royal Delivery','Freeze',
      'Skeletons','Ice Spirit','Fire Spirit','Bats','Spear Goblins','Goblins','Goblin Gang','Guards','Skeleton Army','Wall Breakers',
      'Archers','Knight','Bomber','Ice Golem','Minions','Minion Horde','Dart Goblin','Barbarians','Royal Recruits','Royal Hogs','Zappies','Rascals',
      'Musketeer','Hunter','Wizard','Ice Wizard','Electro Wizard','Magic Archer','Mother Witch',
      'Valkyrie','Mini P.E.K.K.A','Dark Prince','Prince','Bandit','Battle Ram','Cannon Cart','Ram Rider','Lumberjack','Battle Healer','Fisherman','Monk',
      'P.E.K.K.A','Giant','Giant Skeleton','Goblin Giant','Royal Giant','Hog Rider','Mega Knight','Sparky','Balloon',
      'X-Bow','Mortar','Cannon','Bomb Tower','Tesla','Inferno Tower','Furnace','Tombstone','Goblin Cage','Goblin Hut','Barbarian Hut','Elixir Collector','Goblin Drill',
      'Baby Dragon','Inferno Dragon','Electro Dragon','Skeleton Dragons','Phoenix',
      'Mega Minion','Flying Machine',
      'Golem','Lava Hound','Graveyard','Miner','Goblin Barrel','Elixir Golem','Electro Giant',
      'Three Musketeers',
      // Your newer/custom cards you mentioned:
      'Spirit Empress','Goblin Curse','Goblin Machine','Void','Vines','Goblin Demolisher','Suspicious Bush','Rune Giant','Little Prince','Goblinstein','Boss Bandit',
      // Champions:
      'Archer Queen','Skeleton King','Golden Knight','Mighty Miner'
    ];

    // =========================
    // 2) HELPERS (DOM + Images)
    // =========================
    const el = id => document.getElementById(id);
    const screens = { setup: el("screen-setup"), pass: el("screen-pass"), summary: el("screen-summary") };
    const show = name => { Object.values(screens).forEach(s => s.classList.add("hidden")); screens[name].classList.remove("hidden"); };

    function shuffle(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function filenameForCard(name){ return name.toLowerCase().replace(/[^a-z0-9]/g,'') + '.png'; }

    function setCardImageByName(name){
      const img = el('cardImg');
      img.style.display = 'none';
      img.loading = 'eager';
      img.decoding = 'async';
      img.referrerPolicy = 'no-referrer';

      // Optional impostor image
      if(name === '__IMPOSTOR__' && IMPOSTOR_IMAGE_URL){
        img.onload = () => img.style.display = 'block';
        img.onerror = () => { img.removeAttribute('src'); img.style.display='none'; };
        img.src = IMPOSTOR_IMAGE_URL;
        return;
      }

      const file = filenameForCard(name);
      const urls = IMAGE_FOLDERS.map(folder => `${RAW_BASE}/${encodeURIComponent(folder)}/${file}`);
      let i = 0;

      function tryNext(){
        if(i >= urls.length){
          img.removeAttribute('src');
          img.style.display='none';
          return;
        }
        img.onerror = () => { i++; tryNext(); };
        img.onload  = () => { img.style.display = 'block'; };
        img.src = urls[i];
      }
      tryNext();
    }

    function prefetchCardImage(name){
      if(!name || name==='__IMPOSTOR__') return;
      const file = filenameForCard(name);
      IMAGE_FOLDERS.forEach(folder => {
        const i = new Image();
        i.decoding = 'async';
        i.referrerPolicy = 'no-referrer';
        i.src = `${RAW_BASE}/${encodeURIComponent(folder)}/${file}`;
      });
    }

    // =========================
    // 3) GAME STATE
    // =========================
    const state = {
      players: 4,
      impostors: 1,
      randomImpostors: false,

      selectedMode: 'clash',   // 'clash'|'dark'|'darkWild'|'random'
      roundMode: 'clash',      // actual mode used this round

      difficulty: 'medium',    // 'easy'|'medium'|'hard' (used in dark modes)

      realCard: '',
      assignments: [],         // 'IMPOSTOR'|'REAL' per player
      fakeCards: [],           // card per player (only used in dark modes)

      turn: 0,
      revealed: false,
      history: [],

      // Light repetition-avoid
      lastReal: null,
      lastFakes: new Set()
    };

    // =========================
    // 4) SETUP UI LOGIC
    // =========================
    function setMode(newMode){
      state.selectedMode = newMode;

      el('modeClash').classList.toggle('primary', newMode==='clash');
      el('modeDark').classList.toggle('primary', newMode==='dark');
      el('modeDarkWild').classList.toggle('primary', newMode==='darkWild');
      el('modeRandom').classList.toggle('primary', newMode==='random');

      const showDarkControls = (newMode === 'dark' || newMode === 'darkWild' || newMode === 'random');
      el('darkControls').style.display = showDarkControls ? 'grid' : 'none';
    }

    function setPlayers(n){
      state.players = Math.max(3, Math.min(20, n));
      el('playersValue').textContent = String(state.players);

      // Clamp impostors to [0..players]
      state.impostors = Math.max(0, Math.min(state.players, state.impostors));
      el('impostors').value = String(state.impostors);
    }

    function readSetup(){
      // players come from stepper
      // impostors from input (unless random)
      state.impostors = parseInt(el('impostors').value || '0', 10);
      if(Number.isNaN(state.impostors)) state.impostors = 0;
      state.impostors = Math.max(0, Math.min(state.players, state.impostors));
      el('impostors').value = String(state.impostors);

      state.difficulty = el('difficulty').value || 'medium';
    }

    function setRandomImpostors(on){
      state.randomImpostors = !!on;
      el('toggleRandomImps').classList.toggle('on', state.randomImpostors);
      el('toggleRandomImps').textContent = state.randomImpostors ? 'Random impostors: ON' : 'Random impostors: OFF';

      el('impostors').disabled = state.randomImpostors;
      el('impostors').style.opacity = state.randomImpostors ? '0.6' : '1';

      if(state.randomImpostors){
        el('impostors').value = String(state.impostors); // keep internal value, but disabled
      }
    }

    function resetSetup(){
      setPlayers(4);
      state.impostors = 1;
      el('impostors').value = '1';
      setRandomImpostors(false);
      el('difficulty').value = 'medium';
      setMode('clash');
    }

    // =========================
    // 5) ROUND MODE CHOICE
    // =========================
    function chooseRoundMode(){
      if(state.selectedMode !== 'random') return state.selectedMode;

      // Random per round (switches every new round)
      const modes = ['clash','dark','darkWild'];
      return modes[Math.floor(Math.random()*modes.length)];
    }

    function chooseImpostorCount(players){
      if(!state.randomImpostors) return Math.max(0, Math.min(players, state.impostors));

      // Weighted random: mostly 1..players-1, rarely 0 or all players.
      if(players <= 0) return 0;
      if(players === 1) return Math.random() < 0.5 ? 0 : 1;

      const r = Math.random();
      if(r < 0.10) return 0;
      if(r > 0.90) return players;

      // 1..players-1
      return 1 + Math.floor(Math.random() * (players - 1));
    }

    // =========================
    // 6) CARD META + SIMILARITY ENGINE
    //    (stats ignored; semantic/visual/role based)
    // =========================
    const SPELLS = new Set([
      'Arrows','Zap','Giant Snowball','Royal Delivery','Fireball','Rocket','Earthquake','Rage','Goblin Barrel','Freeze','Mirror','Lightning','Poison','Tornado','Clone','Barbarian Barrel','Void','Goblin Curse','Vines','Graveyard','The Log'
    ]);

    const BUILDINGS = new Set([
      'Cannon','Mortar','Tesla','Goblin Hut','Inferno Tower','Bomb Tower','Barbarian Hut','Elixir Collector','Tombstone','Furnace','Goblin Cage','X-Bow','Goblin Drill'
    ]);

    const AIR_TROOPS = new Set([
      'Minions','Minion Horde','Bats','Baby Dragon','Inferno Dragon','Electro Dragon','Skeleton Dragons','Phoenix','Mega Minion','Flying Machine','Lava Hound','Balloon'
    ]);

    // Role buckets (coarse, for similarity)
    const WINCONS = new Set(['Hog Rider','Balloon','Giant','Golem','Lava Hound','Goblin Giant','Royal Giant','Miner','Graveyard','Goblin Barrel','Goblin Drill','Battle Ram','Ram Rider','X-Bow','Mortar','Elixir Golem','Electro Giant','Three Musketeers']);
    const TANKS = new Set(['Giant','Golem','Lava Hound','Royal Giant','Goblin Giant','Electro Giant','P.E.K.K.A','Mega Knight','Giant Skeleton','Elixir Golem','Rune Giant']);
    const CONTROL = new Set(['Tornado','Freeze','Ice Wizard','Electro Wizard','Zappies','Lightning','Bowler','Fisherman','Monk','Vines','Earthquake','Poison','The Log','Giant Snowball','Zap']);
    const SPAWNERS = new Set(['Witch','Night Witch','Tombstone','Goblin Hut','Barbarian Hut','Furnace','Goblin Drill','Goblin Cage','Graveyard','Royal Delivery','Mother Witch','Goblin Curse']);
    const SIEGE = new Set(['X-Bow','Mortar']);
    const ECONOMY = new Set(['Elixir Collector']);

    // Strong named/theme families
    const FAMILY_KEYWORDS = [
      'goblin','skeleton','ice','electro','dragon','spirit','royal','barbarian','witch','giant','golem','hog','miner','bandit','wizard','knight','prince','monk','phoenix','inferno','poison','log','bomb','cannon','mortar','tesla','xbow','grave'
    ];

    // Manual overrides for the special cards you described (visual/identity)
    const OVERRIDE_TAGS = {
      'Mother Witch': { visuals:['granny','blue eyes','purple','pink'], families:['witch','curse','hog'], mechanics:['curse','transform','spawn'] },
      'Phoenix': { visuals:['phoenix','fire bird','egg'], families:['phoenix','fire'], mechanics:['revive','egg','death_damage'] },
      'Goblin Machine': { visuals:['baby goblin','goggles','machine','rocket'], families:['goblin','machine'], mechanics:['rocket','hybrid'] },
      'Spirit Empress': { visuals:['gold armor','blonde','blue dragon','two forms'], families:['spirit','royal','dragon'], mechanics:['dual_form','air_ground'] },
      'Mighty Miner': { visuals:['orange mustache','helmet','drill'], families:['miner','machine'], mechanics:['ramp_damage','lane_swap','bomb'] },
      'Skeleton King': { visuals:['crown','spiked club'], families:['skeleton','royal'], mechanics:['soul','summon'] },
      'Archer Queen': { visuals:['purple hair','crown','cape'], families:['royal','archer'], mechanics:['cloak','speed_boost'] },
      'Golden Knight': { visuals:['gold armor','gold hair','blue eyes'], families:['royal','knight'], mechanics:['dash_chain'] },
      'Monk': { visuals:['bald','beads','white beard','reflect'], families:['monk'], mechanics:['reflect','combo','pushback'] },
      'Little Prince': { visuals:['kid','crown','crossbow','guardian'], families:['royal','prince'], mechanics:['ramp_speed','summon_guardian'] },
      'Goblinstein': { visuals:['scientist goblin','big monster','electric link'], families:['goblin','electric'], mechanics:['stun','dual_unit','ability'] },
      'Boss Bandit': { visuals:['red hair','cape','covered face'], families:['bandit'], mechanics:['dash','invis','teleport','grenades'] }
    };

    function cardType(name){
      if(SPELLS.has(name)) return 'spell';
      if(BUILDINGS.has(name)) return 'building';
      return 'troop';
    }

    function movement(name){
      const t = cardType(name);
      if(t === 'building') return 'static';
      if(t === 'spell') return 'spell';
      return AIR_TROOPS.has(name) ? 'air' : 'ground';
    }

    function baseRoles(name){
      const roles = new Set();
      if(WINCONS.has(name)) roles.add('wincon');
      if(TANKS.has(name)) roles.add('tank');
      if(CONTROL.has(name)) roles.add('control');
      if(SPAWNERS.has(name)) roles.add('spawner');
      if(SIEGE.has(name)) roles.add('siege');
      if(ECONOMY.has(name)) roles.add('economy');

      // fallback
      if(roles.size === 0){
        const t = cardType(name);
        if(t === 'spell') roles.add('spell');
        else if(t === 'building') roles.add('defense');
        else roles.add('dps');
      }
      return [...roles];
    }

    function inferFamilies(name){
      const low = name.toLowerCase();
      const fam = new Set();

      // keyword-based
      for(const k of FAMILY_KEYWORDS){
        if(low.includes(k)) fam.add(k);
      }

      // special canonical families
      if(low.includes('e-wiz') || low.includes('electro')) fam.add('electro');
      if(low.includes('inferno')) fam.add('inferno');
      if(low.includes('grave')) fam.add('skeleton');
      if(low.includes('hog')) fam.add('hog');
      if(low.includes('barrel')) fam.add('barbarian'); // barbarian barrel
      if(low.includes('queen') || low.includes('king') || low.includes('prince') || low.includes('knight') || low.includes('royal')) fam.add('royal');

      // overrides
      const o = OVERRIDE_TAGS[name];
      if(o?.families) o.families.forEach(x => fam.add(x));

      return [...fam];
    }

    function inferMechanics(name){
      const low = name.toLowerCase();
      const mech = new Set();

      // generic by name
      if(low.includes('freeze')) mech.add('freeze');
      if(low.includes('tornado')) mech.add('pull');
      if(low.includes('zap') || low.includes('electro') || low.includes('lightning') || low.includes('zappies')) mech.add('stun');
      if(low.includes('poison')) mech.add('dot');
      if(low.includes('rage')) mech.add('buff');
      if(low.includes('clone') || low.includes('mirror')) mech.add('copy');
      if(low.includes('log') || low.includes('snowball') || low.includes('bowler')) mech.add('knockback');
      if(low.includes('barrel')) mech.add('roll');
      if(low.includes('drill') || low.includes('miner')) mech.add('burrow');
      if(low.includes('charge') || low.includes('ram') || low.includes('prince') || low.includes('bandit') || low.includes('knight')) mech.add('charge_dash');

      // category-based
      if(SPAWNERS.has(name)) mech.add('spawn');
      if(name === 'Inferno Tower' || name === 'Inferno Dragon') mech.add('ramp');
      if(name === 'Electro Giant') mech.add('reflect');
      if(name === 'Phoenix') mech.add('revive');

      // overrides
      const o = OVERRIDE_TAGS[name];
      if(o?.mechanics) o.mechanics.forEach(x => mech.add(x));

      return [...mech];
    }

    function inferVisuals(name){
      const low = name.toLowerCase();
      const vis = new Set();

      // very light, but useful
      if(low.includes('ice') || low.includes('snow')) vis.add('blue');
      if(low.includes('fire') || low.includes('inferno') || low.includes('phoenix')) vis.add('fire');
      if(low.includes('electro') || low.includes('zap') || low.includes('lightning') || low.includes('tesla')) vis.add('electric');
      if(low.includes('goblin')) vis.add('green');
      if(low.includes('skeleton') || low.includes('grave')) vis.add('undead');
      if(low.includes('royal') || low.includes('king') || low.includes('queen') || low.includes('prince') || low.includes('knight')) vis.add('crown');

      // overrides (your appearance cues)
      const o = OVERRIDE_TAGS[name];
      if(o?.visuals) o.visuals.forEach(x => vis.add(x));

      return [...vis];
    }

    const CARD_DB = new Map();
    const SIM_CACHE = new Map(); // key: real|difficulty => ranked list

    function buildCardDB(){
      CARD_DB.clear();
      for(const name of CLASH_CARDS){
        const t = cardType(name);
        const entry = {
          name,
          type: t,
          move: movement(name),
          roles: baseRoles(name),
          families: inferFamilies(name),
          mechanics: inferMechanics(name),
          visuals: inferVisuals(name)
        };
        CARD_DB.set(name, entry);
      }
    }

    function overlapCount(a, b){
      let c = 0;
      const setB = new Set(b);
      for(const x of a) if(setB.has(x)) c++;
      return c;
    }

    function similarityScore(real, cand){
      const A = CARD_DB.get(real);
      const B = CARD_DB.get(cand);
      if(!A || !B) return -Infinity;
      if(real === cand) return -Infinity;

      let s = 0;

      // Type + movement (strong)
      if(A.type === B.type) s += 6;
      if(A.move === B.move) s += 3;

      // Roles / families / mechanics / visuals
      const roleOv = overlapCount(A.roles, B.roles);
      const famOv  = overlapCount(A.families, B.families);
      const mecOv  = overlapCount(A.mechanics, B.mechanics);
      const visOv  = overlapCount(A.visuals, B.visuals);

      s += Math.min(10, roleOv * 5);
      s += Math.min(10, famOv  * 3);
      s += Math.min(12, mecOv  * 4);
      s += Math.min(6,  visOv  * 2);

      // Encourage "same theme even across types" (spells/buildings impersonating troops)
      if(A.type !== B.type && famOv >= 2) s += 3;
      if(A.type !== B.type && mecOv >= 2) s += 2;

      // Small penalty if wildly different and nothing overlaps
      if(roleOv === 0 && famOv === 0 && mecOv === 0) s -= 6;

      return s;
    }

    function rankedCandidates(real, difficulty){
      const key = `${real}__${difficulty}`;
      if(SIM_CACHE.has(key)) return SIM_CACHE.get(key);

      const scored = [];
      for(const c of CLASH_CARDS){
        if(c === real) continue;
        scored.push({ c, s: similarityScore(real, c) });
      }
      scored.sort((a,b)=>b.s-a.s);

      // Difficulty: filter/shape pool (not just thresholds)
      let pool = scored;

      if(difficulty === 'easy'){
        // very strict: take top 12, but only if somewhat aligned
        pool = scored.filter(x => x.s >= 10).slice(0, 12);
        if(pool.length < 6) pool = scored.slice(0, 10);
      } else if(difficulty === 'medium'){
        pool = scored.filter(x => x.s >= 7).slice(0, 28);
        if(pool.length < 10) pool = scored.slice(0, 20);
      } else { // hard
        pool = scored.filter(x => x.s >= 4).slice(0, 45);
        if(pool.length < 14) pool = scored.slice(0, 30);
      }

      SIM_CACHE.set(key, pool);
      return pool;
    }

    function weightedPickTop(pool){
      // pool is sorted-ish; weight favors earlier entries strongly
      if(!pool.length) return null;
      const n = pool.length;
      // weights: 1/(i+1)^1.2
      let sum = 0;
      const weights = [];
      for(let i=0;i<n;i++){
        const w = 1 / Math.pow(i+1, 1.2);
        weights.push(w);
        sum += w;
      }
      let r = Math.random() * sum;
      for(let i=0;i<n;i++){
        r -= weights[i];
        if(r <= 0) return pool[i].c;
      }
      return pool[0].c;
    }

    function pickFakeCard(real, difficulty, avoidSet){
      const pool = rankedCandidates(real, difficulty).filter(x => x.c !== real);
      if(!pool.length) return CLASH_CARDS[Math.floor(Math.random()*CLASH_CARDS.length)];

      // Avoid repeating last round fakes if possible
      const filtered = pool.filter(x => !avoidSet.has(x.c));
      const finalPool = filtered.length >= 6 ? filtered : pool;

      return weightedPickTop(finalPool);
    }

    // =========================
    // 7) ROUND GENERATION
    // =========================
    function pickRealCard(){
      // Avoid repeating the exact same real card if possible
      let pick = null;
      for(let tries=0; tries<6; tries++){
        const c = CLASH_CARDS[Math.floor(Math.random()*CLASH_CARDS.length)];
        if(c !== state.lastReal){
          pick = c;
          break;
        }
        pick = c;
      }
      return pick;
    }

    function assignRoles(impostorCount){
      const roles = Array(state.players).fill('REAL');
      const idx = shuffle([...Array(state.players)].map((_,i)=>i));
      for(let i=0;i<impostorCount;i++){
        roles[idx[i]] = 'IMPOSTOR';
      }
      state.assignments = roles;
    }

    function assignFakeCardsForDarkModes(){
      state.fakeCards = Array(state.players).fill(null);
      const avoid = new Set(state.lastFakes);

      if(state.roundMode === 'dark'){
        const fake = pickFakeCard(state.realCard, state.difficulty, avoid);
        for(let i=0;i<state.players;i++){
          if(state.assignments[i] === 'IMPOSTOR') state.fakeCards[i] = fake;
        }
        prefetchCardImage(fake);
        return;
      }

      if(state.roundMode === 'darkWild'){
        const used = new Set();
        for(let i=0;i<state.players;i++){
          if(state.assignments[i] !== 'IMPOSTOR') continue;

          // avoid duplicates within the round if possible
          const localAvoid = new Set([...avoid, ...used]);
          let fake = pickFakeCard(state.realCard, state.difficulty, localAvoid);

          // fallback: if still collides, try a couple rerolls from ranked pool
          if(used.has(fake)){
            const pool = rankedCandidates(state.realCard, state.difficulty).map(x=>x.c);
            for(const candidate of pool){
              if(candidate !== state.realCard && !used.has(candidate) && !avoid.has(candidate)){
                fake = candidate; break;
              }
            }
          }

          state.fakeCards[i] = fake;
          used.add(fake);
          prefetchCardImage(fake);
        }
        return;
      }
    }

    function beginRound(){
      readSetup();

      state.roundMode = chooseRoundMode();
      const impCount = chooseImpostorCount(state.players);

      // pick real card + prefetch
      state.realCard = pickRealCard();
      prefetchCardImage(state.realCard);

      assignRoles(impCount);

      // assign fakes (only in dark modes)
      if(state.roundMode === 'dark' || state.roundMode === 'darkWild'){
        assignFakeCardsForDarkModes();
      } else {
        state.fakeCards = Array(state.players).fill(null);
      }

      // reset pass flow
      state.turn = 0;
      state.revealed = false;
      state.history = [];

      // update repetition memory
      state.lastReal = state.realCard;
      state.lastFakes = new Set(state.fakeCards.filter(Boolean));

      show('pass');
      updatePassUI();
    }

    // =========================
    // 8) PASS SCREEN RENDERING
    // =========================
    function modeLabel(m){
      if(m==='clash') return 'Clash Royale Impostor';
      if(m==='dark') return 'In the Dark';
      if(m==='darkWild') return 'In the Dark (Wild)';
      return 'Random Mode';
    }

    function cardForCurrentPlayer(){
      const role = state.assignments[state.turn];
      const isImp = role === 'IMPOSTOR';

      if(state.roundMode === 'clash'){
        if(isImp) return { text:'IMPOSTOR', color:'var(--danger)', img:'__IMPOSTOR__', showName:false };
        return { text:state.realCard, color:'var(--text)', img:state.realCard, showName:true };
      }

      // dark / darkWild: no impostor label
      if(isImp){
        const fake = state.fakeCards[state.turn] || state.realCard;
        return { text:fake, color:'var(--text)', img:fake, showName:true };
      }
      return { text:state.realCard, color:'var(--text)', img:state.realCard, showName:true };
    }

    function updatePassUI(){
      el('turnInfo').textContent = `Player ${state.turn+1} / ${state.players}`;

      const img = el('cardImg');
      if(!state.revealed){
        el('wordText').textContent = 'Tap to reveal';
        el('wordText').style.color = 'var(--text)';
        el('hint').textContent = 'Hand the phone to this player before tapping.';
        el('toggleBtn').textContent = 'Reveal';
        img.removeAttribute('src');
        img.style.display = 'none';
        return;
      }

      const info = cardForCurrentPlayer();
      el('wordText').textContent = info.text;
      el('wordText').style.color = info.color;

      // image
      if(state.roundMode === 'clash' && info.text === 'IMPOSTOR' && !IMPOSTOR_IMAGE_URL){
        img.removeAttribute('src');
        img.style.display='none';
      } else {
        setCardImageByName(info.img);
      }

      // hint line
      if(state.turn === state.players-1){
        el('hint').textContent = 'Last player revealed. Tap again to finish.';
        el('toggleBtn').textContent = 'Finish Round';
      } else {
        // Mode-specific guidance
        if(state.roundMode === 'clash'){
          el('hint').textContent = 'Tap Next Player and pass the phone.';
        } else {
          el('hint').textContent = 'Don’t say the card name. Describe it vaguely, then pass the phone.';
        }
        el('toggleBtn').textContent = 'Next Player';
      }
    }

    function nextTurn(){
      state.history.push({ player: state.turn+1, role: state.assignments[state.turn], shown: cardForCurrentPlayer().text });
      state.turn++;
      state.revealed = false;

      if(state.turn >= state.players){
        showSummary();
        return;
      }
      updatePassUI();
    }

    function showSummary(){
      show('summary');

      const impPlayers = state.history.filter(h => h.role === 'IMPOSTOR').map(h => `Player ${h.player}`);
      const impCount = impPlayers.length;

      el('roundInfoPill').textContent = `${modeLabel(state.roundMode)} • Real card: ${state.realCard}`;
      if(state.roundMode === 'clash'){
        el('summaryText').innerHTML =
          `Most players saw <b>${state.realCard}</b>. Impostors saw <b style="color:var(--danger)">IMPOSTOR</b>. Discuss clues without saying the name.`;
      } else {
        const uniqueFakes = [...new Set(state.fakeCards.filter(Boolean))];
        const fakesText = uniqueFakes.length ? uniqueFakes.join(', ') : '(none)';
        el('summaryText').innerHTML =
          `Most players saw <b>${state.realCard}</b>. Impostors saw a <b>similar</b> card instead. Difficulty: <b>${state.difficulty}</b>.<br/><span style="color:var(--muted)">Fake card(s) used this round: ${fakesText}</span>`;
      }

      el('impostorList').classList.add('hidden');
      el('impostorList').textContent = impCount ? `Impostors: ${impPlayers.join(', ')}` : 'Impostors: none';
    }

    // =========================
    // 9) EVENTS
    // =========================
    el('modeClash').onclick = () => setMode('clash');
    el('modeDark').onclick = () => setMode('dark');
    el('modeDarkWild').onclick = () => setMode('darkWild');
    el('modeRandom').onclick = () => setMode('random');

    el('playersMinus').onclick = () => setPlayers(state.players - 1);
    el('playersPlus').onclick  = () => setPlayers(state.players + 1);

    el('impostors').addEventListener('input', () => {
      state.impostors = parseInt(el('impostors').value || '0', 10);
      if(Number.isNaN(state.impostors)) state.impostors = 0;
      state.impostors = Math.max(0, Math.min(state.players, state.impostors));
      el('impostors').value = String(state.impostors);
    });

    el('toggleRandomImps').onclick = () => setRandomImpostors(!state.randomImpostors);

    el('begin').onclick = () => beginRound();
    el('resetAllSetup').onclick = () => resetSetup();
    el('toggleBtn').onclick = () => {
      if(!state.revealed){
        state.revealed = true;
        updatePassUI();
      } else {
        nextTurn();
      }
    };
    el('showImpostors').onclick = () => {
      el('impostorList').classList.remove('hidden');
    };
    el('playAgain').onclick = () => show('setup');

    // =========================
    // 10) INIT
    // =========================
    buildCardDB();
    resetSetup();
  </script>
</body>
</html>
