<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Clash Royale Imposter</title>
  <link rel="preconnect" href="https://raw.githubusercontent.com" />
  <style>
    :root { --bg:#0f172a; --panel:#0b1220; --text:#e5e7eb; --muted:#94a3b8; --accent:#22c55e; --danger:#ef4444; --primary:#0ea5e9; }
    *{box-sizing:border-box;font-family:system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif}
    body{margin:0;min-height:100vh;background:linear-gradient(180deg,#0a0f1c,#0f172a);color:var(--text);display:flex;align-items:center}
    .wrap{width:100%;max-width:760px;margin:0 auto;padding:20px}
    .card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:20px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    h1{margin:0 0 10px;font-size:28px}
    p.sub{margin:0 0 16px;color:var(--muted)}
    .modebar{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:10px}
    .modebtn{padding:10px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(56,189,248,.1);color:#c7f9ff;font-weight:700}
    .modebtn.primary{background:#38bdf8;color:#031d2c}
    .modebtn.disabled{opacity:.5;cursor:not-allowed}
    label{display:block;margin:8px 0 4px;color:var(--muted);font-size:14px}
    input{width:100%;padding:12px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0e1526;color:var(--text)}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .btn{width:100%;padding:14px 16px;border-radius:14px;border:1px solid rgba(255,255,255,.1);background:#152235;color:var(--text);font-weight:800;font-size:16px;cursor:pointer}
    .btn.primary{background:var(--primary);border-color:rgba(14,165,233,.5)}
    .btn.success{background:var(--accent);color:#052e16;border:none}
    .btn.danger{background:var(--danger);border:none}
    .center{display:flex;flex-direction:column;align-items:center;text-align:center;gap:14px}
    .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);font-size:12px;color:var(--muted)}
    .divider{height:1px;background:rgba(255,255,255,.08);margin:12px 0}
    .hidden{display:none}
    .wordStage{display:grid;grid-template-columns:1fr;gap:16px;width:100%}

    .wordCard{border-radius:24px;border:2px dashed rgba(255,255,255,.15);padding:16px 16px 20px;min-height:300px;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;gap:12px}
    .wordText{font-size:36px;font-weight:800;letter-spacing:.4px;text-align:center;word-break:break-word;max-width:100%}

    .imageSlot{width:100%;max-width:320px;aspect-ratio:1/1;display:flex;align-items:center;justify-content:center;border-radius:18px;border:1px dashed rgba(255,255,255,.14);background:rgba(255,255,255,.02)}
    #cardImg{max-width:100%;max-height:100%;object-fit:contain;display:none}

    .hint{color:var(--muted);font-size:14px;margin-top:-6px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="modebar">
      <button class="modebtn primary" id="modeClash" type="button">Clash Royale Imposter</button>
      <button class="modebtn" id="modeDark" type="button">Clash Royale in the Dark</button>
      <button class="modebtn disabled" id="modeCustom" type="button">Custom Word Imposter</button>
    </div>

    <div class="card" id="screen-setup">
      <h1>Clash Royale Imposter</h1>
      <p class="sub">Add players and impostors, then start. The word list is hidden. Extra space is reserved for card images.</p>

      <div class="row">
        <div>
          <label for="players">Players</label>
          <input id="players" type="number" min="3" max="20" value="6" />
        </div>
        <div>
          <label for="impostors">Impostors (â‰¤ players)</label>
          <input id="impostors" type="number" min="1" value="1" />
        </div>
      </div>

      <div class="row" id="darkControls" style="margin-top:12px; display:none">
        <div>
          <label for="darkDifficulty">Dark Mode Difficulty</label>
          <select id="darkDifficulty" style="width:100%;padding:12px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0e1526;color:var(--text)">
            <option value="easy">Easy (same type)</option>
            <option value="medium">Medium (same type)</option>
            <option value="hard">Hard (mostly random)</option>
            <option value="chaos">Chaos (random)</option>
          </select>
        </div>
        <div></div>
      </div>

      <div class="row" style="margin-top:12px">
        <button class="btn primary" id="begin" type="button">Begin Round</button>
        <button class="btn danger" id="resetAllSetup" type="button">Reset</button>
      </div>
    </div>

    <div class="card hidden" id="screen-pass">
      <div class="center" style="width:100%">
        <div class="pill" id="turnInfo">Player 1 / ?</div>
        <div class="wordStage">
          <div class="wordCard">
            <div class="imageSlot">
              <img id="cardImg" alt="Card" />
            </div>
            <div class="wordText" id="wordText">Tap to reveal</div>
          </div>
          <div class="hint" id="hint">Hand the phone to this player before tapping.</div>
        </div>
        <button class="btn success" id="toggleBtn" type="button" style="width:100%">Reveal</button>
      </div>
    </div>

    <div class="card hidden" id="screen-summary">
      <div class="center">
        <div class="pill">Round finished</div>
        <h1>How to Play</h1>
        <p class="sub" style="max-width:640px">
          Most players saw the same Clash Royale card. Impostors saw <b>IMPOSTOR</b> instead. Discuss clues about the secret card without giving it away.
        </p>
        <button class="btn" id="showImpostors" type="button">Reveal Impostors</button>
        <div id="impostorList" class="sub hidden"></div>
        <div class="divider"></div>
        <button class="btn primary" id="playAgain" type="button">Play Again</button>
      </div>
    </div>
  </div>

  <script>
    // ---------------- Data -----------------
    const CLASH_CARDS = [
      'Arrows','Zap','Snowball','Rage','Clone','Mirror','Heal Spirit','Fireball','Poison','Rocket','Lightning','Earthquake','Tornado','The Log','Barbarian Barrel','Royal Delivery',
      'Skeletons','Ice Spirit','Fire Spirits','Bats','Spear Goblins','Goblins','Goblin Gang','Guards','Skeleton Army','Wall Breakers',
      'Archers','Knight','Bomber','Ice Golem','Minions','Minion Horde','Dart Goblin','Goblin Cage','Goblin Hut','Barbarian Hut','Barbarians','Royal Recruits','Royal Hogs','Zappies','Rascals',
      'Musketeer','Hunter','Wizard','Ice Wizard','Electro Wizard','Magic Archer','Mother Witch',
      'Valkyrie','Mini P.E.K.K.A','Dark Prince','Prince','Bandit','Battle Ram','Cannon Cart','Ram Rider','Lumberjack','Battle Healer','Fisherman','Monk',
      'P.E.K.K.A','Giant','Giant Skeleton','Goblin Giant','Royal Giant','Hog Rider','Mega Knight','Sparky','Balloon','X-Bow','Mortar','Cannon','Bomb Tower','Tesla','Inferno Tower','Furnace','Tombstone',
      'Baby Dragon','Inferno Dragon','Electro Dragon','Skeleton Dragons','Phoenix',
      'Mega Minion','Minion Horde','Flying Machine',
      'Golem','Lava Hound','Graveyard','Miner','Goblin Barrel','Goblin Drill','Elixir Golem','Electro Giant',
      'Three Musketeers','Elixir Collector','Spirit Empress','Berserker','Goblin Curse','Goblin Machine','Void','Vines','Goblin Demolisher','Suspicious Bush','Rune Giant',
      'Archer Queen','Skeleton King','Golden Knight','Mighty Miner','Little Prince','Goblinstein'
    ];

    const RAW_BASE = "https://raw.githubusercontent.com/methmonster34/clash-royale-impostor/main";
    const IMAGE_FOLDERS = ["Clash Royale Imposter Images", "Clash Royale Imposter Images 2"]; // keep both

    // --------------- Helpers ----------------
    const el = id => document.getElementById(id);
    const screens = { setup: el("screen-setup"), pass: el("screen-pass"), summary: el("screen-summary") };
    let mode = 'clash'; // 'clash' | 'dark'
    const show = name => { Object.values(screens).forEach(s => s.classList.add("hidden")); screens[name].classList.remove("hidden"); };

    function filenameForCard(name){ return name.toLowerCase().replace(/[^a-z0-9]/g,'') + '.png'; }

    function setCardImage(name){
      const img = el('cardImg');
      const file = filenameForCard(name);
      const urls = IMAGE_FOLDERS.map(folder => `${RAW_BASE}/${encodeURIComponent(folder)}/${file}`);

      img.style.display = 'none';
      img.loading = 'eager';
      img.decoding = 'async';

      let i = 0;
      function tryNext(){
        if(i >= urls.length){ img.removeAttribute('src'); img.style.display='none'; return; }
        const url = urls[i];
        img.onerror = () => { i++; tryNext(); };
        img.onload  = () => { img.style.display = 'block'; };
        img.src = url; // allow cache for speed
      }
      tryNext();
    }

    function prefetchCardImage(name){
      const file = filenameForCard(name);
      IMAGE_FOLDERS.forEach(folder => {
        const i = new Image();
        i.decoding = 'async';
        i.src = `${RAW_BASE}/${encodeURIComponent(folder)}/${file}`;
      });
    }

    // --------------- State ------------------
    let state = { players:6, impostors:1, assignments:[], word:"", turn:0, revealed:false, history:[], impostorAlts:[] };

    function clampImpostors(){
      const p = state.players;
      if(state.impostors < 1) state.impostors = 1;
      if(state.impostors > p) state.impostors = p;
      el('impostors').value = String(state.impostors);
    }

    function readSetup(){
      state.players = Math.max(3, Math.min(20, parseInt(el('players').value || '6')));
      state.impostors = parseInt(el('impostors').value || '1');
      clampImpostors();
    }

    function randomWord(){
      state.word = CLASH_CARDS[Math.floor(Math.random()*CLASH_CARDS.length)];
      prefetchCardImage(state.word);
    }

    function assignRoles(){
      const arr = Array(state.players).fill('WORD');
      const impCount = Math.min(state.impostors, state.players);
      const used = new Set();
      while(used.size < impCount) used.add(Math.floor(Math.random()*state.players));
      for(const i of used) arr[i] = 'IMPOSTOR';
      state.assignments = arr;
      state.impostorAlts = Array(state.players).fill(null);
      if(mode === 'dark'){
        // choose alt card for impostors
        const alts = [];
        for(let i=0;i<state.players;i++){
          if(arr[i] === 'IMPOSTOR'){
            const alt = pickSimilar(state.word, el('darkDifficulty')?.value || 'easy');
            state.impostorAlts[i] = alt;
            alts.push(alt);
          }
        }
        // prefetch impostor images too
        alts.forEach(a => prefetchCardImage(a));
      }
      state.turn = 0; state.revealed = false; state.history = [];
    }

    function updatePassUI(){
      el('turnInfo').textContent = `Player ${state.turn+1} / ${state.players}`;
      const img = el('cardImg');

      if(!state.revealed){
        el('wordText').textContent = 'Tap to reveal';
        el('wordText').style.color = 'var(--text)';
        el('hint').textContent = 'Hand the phone to this player before tapping.';
        el('toggleBtn').textContent = 'Reveal';
        img.removeAttribute('src');
        img.style.display = 'none';
      } else {
        const isImp = state.assignments[state.turn] === 'IMPOSTOR';
        let roleText, cardName;
        if(isImp && mode === 'dark'){
          cardName = state.impostorAlts[state.turn] || state.word;
          roleText = cardName; // impostor sees a legit-looking card
          el('wordText').style.color = 'var(--text)';
          setCardImage(cardName);
        } else if(isImp){
          roleText = 'IMPOSTOR';
          el('wordText').style.color = 'var(--danger)';
          img.removeAttribute('src'); img.style.display='none';
        } else {
          cardName = state.word;
          roleText = state.word;
          el('wordText').style.color = 'var(--text)';
          setCardImage(cardName);
        }
        el('wordText').textContent = roleText;
        el('hint').textContent = state.turn === state.players-1 ? 'Last player revealed. Tap again to finish.' : 'Tap Next Player and pass the phone.';
        el('toggleBtn').textContent = state.turn === state.players-1 ? 'Finish Round' : 'Next Player';
      }
    }

    function nextTurn(){
      state.history.push({ player: state.turn+1, role: state.assignments[state.turn] });
      state.turn++;
      state.revealed = false;
      if(state.turn >= state.players){
        show('summary');
        el('impostorList').classList.add('hidden');
        el('impostorList').textContent = '';
        return;
      }
      updatePassUI();
    }

    // -------------- Events ------------------
    el('players').addEventListener('input', () => {
      state.players = Math.max(3, Math.min(20, parseInt(el('players').value || '6')));
      clampImpostors();
    });
    el('impostors').addEventListener('input', () => {
      state.impostors = parseInt(el('impostors').value || '1');
      clampImpostors();
    });

    el('begin').onclick = () => { readSetup(); randomWord(); assignRoles(); show('pass'); updatePassUI(); };
    el('resetAllSetup').onclick = () => { el('players').value = '6'; el('impostors').value = '1'; state.players=6; state.impostors=1; };
    el('toggleBtn').onclick = () => { if(!state.revealed){ state.revealed = true; updatePassUI(); } else { nextTurn(); } };
    el('showImpostors').onclick = () => {
      const list = state.history.filter(h => h.role === 'IMPOSTOR').map(h => `Player ${h.player}`).join(', ');
      el('impostorList').textContent = list ? `Impostors: ${list}` : 'No impostors recorded.';
      el('impostorList').classList.remove('hidden');
    };
    el('playAgain').onclick = () => { show('setup'); };

    // -------- Mode switching --------
    function setMode(newMode){
      mode = newMode;
      // visual toggle
      el('modeClash').classList.toggle('primary', mode==='clash');
      el('modeDark').classList.toggle('primary', mode==='dark');
      // show difficulty for dark
      el('darkControls').style.display = mode==='dark' ? 'grid' : 'none';
    }
    el('modeClash').onclick = () => setMode('clash');
    el('modeDark').onclick = () => setMode('dark');
  // -------- Similarity engine (advanced tags) --------
    // Base category sets
    const SPELLS = new Set(['Arrows','Zap','Snowball','Rage','Clone','Mirror','Fireball','Poison','Rocket','Lightning','Earthquake','Tornado','The Log','Barbarian Barrel','Royal Delivery','Heal Spirit']);
    const BUILDINGS = new Set(['X-Bow','Mortar','Cannon','Bomb Tower','Tesla','Inferno Tower','Furnace','Tombstone','Goblin Cage','Goblin Hut','Barbarian Hut','Elixir Collector','Goblin Drill']);

    // Roles / traits
    const WINCONS = new Set(['Hog Rider','Giant','Goblin Giant','Royal Giant','Balloon','X-Bow','Mortar','Graveyard','Miner','Ram Rider','Battle Ram','Goblin Drill','Elixir Golem','Electro Giant','Golem','Lava Hound','Three Musketeers','Sparky']);
    const SIEGE_BUILDINGS = new Set(['X-Bow','Mortar']);
    const SPAWN_BUILDINGS = new Set(['Furnace','Goblin Hut','Barbarian Hut']);
    const ECON_BUILDINGS = new Set(['Elixir Collector']);
    const BUILDING_TARGETING = new Set(['Giant','Goblin Giant','Royal Giant','Balloon','Hog Rider','Ram Rider','Battle Ram','Golem','Electro Giant','Miner','X-Bow','Mortar','Goblin Drill']);
    const AIR_TROOPS = new Set(['Minions','Minion Horde','Baby Dragon','Inferno Dragon','Electro Dragon','Skeleton Dragons','Phoenix','Mega Minion','Flying Machine','Lava Hound','Balloon']);
    const SPLASH_TROOPS = new Set(['Wizard','Ice Wizard','Baby Dragon','Electro Dragon','Executioner','Valkyrie','Bowler','Witch','Mother Witch','Bomber','Dark Prince','Splash']); // some may not be in list; safe fallback
    const RANGED_TROOPS = new Set(['Archers','Musketeer','Hunter','Wizard','Ice Wizard','Electro Wizard','Magic Archer','Dart Goblin','Flying Machine','Zappies','Rascals','Mother Witch','Princess','Spear Goblins']);

    // Known elixir (partial; others left undefined)
    const ELIXIR = new Map([
      ['Arrows',3],['Zap',2],['Snowball',2],['Rage',2],['Clone',3],['Fireball',4],['Poison',4],['Rocket',6],['Lightning',6],['Earthquake',3],['Tornado',3],['The Log',2],['Barbarian Barrel',2],['Royal Delivery',3],['Heal Spirit',1],
      ['Skeletons',1],['Ice Spirit',1],['Fire Spirits',2],['Bats',2],['Spear Goblins',2],['Goblins',2],['Goblin Gang',3],['Guards',3],['Skeleton Army',3],['Wall Breakers',2],
      ['Archers',3],['Knight',3],['Bomber',2],['Ice Golem',2],['Minions',3],['Minion Horde',5],['Dart Goblin',3],['Goblin Cage',4],['Goblin Hut',5],['Barbarian Hut',7],['Barbarians',5],['Royal Recruits',7],['Royal Hogs',5],['Zappies',4],['Rascals',5],
      ['Musketeer',4],['Hunter',4],['Wizard',5],['Ice Wizard',3],['Electro Wizard',5],['Magic Archer',4],['Mother Witch',4],
      ['Valkyrie',4],['Mini P.E.K.K.A',4],['Dark Prince',4],['Prince',5],['Bandit',3],['Battle Ram',4],['Cannon Cart',5],['Ram Rider',5],['Lumberjack',4],['Battle Healer',4],['Fisherman',3],['Monk',5],
      ['P.E.K.K.A',7],['Giant',5],['Giant Skeleton',6],['Goblin Giant',6],['Royal Giant',6],['Hog Rider',4],['Mega Knight',7],['Sparky',6],['Balloon',5],['X-Bow',6],['Mortar',4],['Cannon',3],['Bomb Tower',4],['Tesla',4],['Inferno Tower',5],['Furnace',4],['Tombstone',3],
      ['Baby Dragon',4],['Inferno Dragon',4],['Electro Dragon',5],['Skeleton Dragons',4],['Phoenix',4],
      ['Mega Minion',3],['Flying Machine',4],
      ['Golem',8],['Lava Hound',7],['Graveyard',5],['Miner',3],['Goblin Barrel',3],['Goblin Drill',4],['Elixir Golem',3],['Electro Giant',8],
      ['Three Musketeers',9],['Elixir Collector',6]
    ]);

    function cardType(name){ return SPELLS.has(name) ? 'spell' : (BUILDINGS.has(name) ? 'building' : 'troop'); }
    function movement(name){ return cardType(name) === 'troop' ? (AIR_TROOPS.has(name) ? 'air' : 'ground') : null; }
    function targets(name){
      if(cardType(name) === 'spell') return ['ground','air'];
      if(cardType(name) === 'building') return [];
      const t = ['ground'];
      if (AIR_TROOPS.has(name)) t.push('air');
      if (BUILDING_TARGETING.has(name)) t.push('buildings');
      return Array.from(new Set(t));
    }
    function roles(name){
      const r = new Set();
      if(WINCONS.has(name)) r.add('wincon');
      if(SIEGE_BUILDINGS.has(name)) r.add('siege');
      if(SPAWN_BUILDINGS.has(name)) r.add('spawner');
      if(ECON_BUILDINGS.has(name)) r.add('economy');
      if(BUILDING_TARGETING.has(name)) r.add('building-target');
      if(SPLASH_TROOPS.has(name) || ['Fireball','Poison','Rocket','Lightning','Earthquake','Tornado','The Log','Barbarian Barrel','Royal Delivery'].includes(name)) r.add('splash/control');
      if(RANGED_TROOPS.has(name)) r.add('ranged'); else if(cardType(name)==='troop') r.add('melee');
      return Array.from(r);
    }
    function elixirOf(name){ return ELIXIR.get(name); }

    function meta(name){
      return {
        type: cardType(name),
        role: roles(name),
        movement: movement(name),
        targets: targets(name),
        range: RANGED_TROOPS.has(name) ? 'ranged' : (cardType(name)==='troop' ? 'melee' : null),
        elixir: elixirOf(name)
      };
    }

    function scoreMatch(base, cand){
      const A = meta(base), B = meta(cand);
      let score = 0;
      if(A.type === B.type) score += 4;
      // role overlap
      const overlap = (A.role||[]).filter(x => (B.role||[]).includes(x)).length; score += overlap * 2;
      // movement/targets similarity
      if(A.movement && B.movement && A.movement === B.movement) score += 1;
      const tgtOverlap = (A.targets||[]).filter(x => (B.targets||[]).includes(x)).length; score += Math.min(2, tgtOverlap);
      // elixir proximity
      if(A.elixir != null && B.elixir != null){
        const diff = Math.abs(A.elixir - B.elixir);
        if(diff === 0) score += 2; else if(diff === 1) score += 1; else if(diff <= 2) score += 0.5;
      }
      return score;
    }

    function pickSimilar(base, difficulty='easy'){
      const candidates = CLASH_CARDS.filter(c => c !== base);
      // compute scores
      const scored = candidates.map(c => ({c, s: scoreMatch(base,c)}));
      // helpers
      const sameType = scored.filter(o => cardType(o.c) === cardType(base));
      const byScore = arr => arr.sort((a,b)=>b.s - a.s);

      if(difficulty === 'easy'){
        // strictly same type; pick highest score among same type
        const pool = byScore(sameType);
        return (pool[0]?.c) || candidates[Math.floor(Math.random()*candidates.length)];
      }
      if(difficulty === 'medium'){
        // prefer same type with at least one shared role/targets; fallback to top same-type
        const A = meta(base);
        const pool = byScore(sameType.filter(o => {
          const B = meta(o.c);
          const roleOverlap = (A.role||[]).some(r => (B.role||[]).includes(r));
          const tgtOverlap = (A.targets||[]).some(t => (B.targets||[]).includes(t));
          return roleOverlap || tgtOverlap;
        }));
        if(pool.length) return pool[0].c;
        const fallback = byScore(sameType);
        return (fallback[0]?.c) || candidates[Math.floor(Math.random()*candidates.length)];
      }
      if(difficulty === 'hard'){
        // 40%: pick best same-type; 60%: pick best overall (could be different type)
        if(Math.random()<0.4){
          const pool = byScore(sameType);
          return (pool[0]?.c) || candidates[Math.floor(Math.random()*candidates.length)];
        }
        const all = byScore(scored);
        return all.find(o=>o.c!==base)?.c || candidates[Math.floor(Math.random()*candidates.length)];
      }
      // chaos: uniform random different card
      return candidates[Math.floor(Math.random()*candidates.length)];
    }

  </script>
</body>
</html>
