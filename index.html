// =========================
// 6) CARD META + SIMILARITY ENGINE (V3)
//    Priority: elemental + physical attributes first, then name similarity.
//    Also blocks a few known bad pairings you reported.
// =========================

// --- hard-block bad match pairs (unordered) ---
const BAD_PAIRS = new Set();
function pairKey(a,b){ return [a,b].sort().join("||"); }
[
  ['Wizard','Guards'],
  ['Battle Ram','Miner'],
  ['Bomber','Magic Archer'],
  ['Goblin Hut','Elixir Collector']
].forEach(([a,b]) => BAD_PAIRS.add(pairKey(a,b)));

const SPELLS = new Set([
  'Arrows','Zap','Giant Snowball','Rage','Clone','Mirror',
  'Fireball','Poison','Rocket','Lightning','Earthquake','Tornado',
  'The Log','Barbarian Barrel','Royal Delivery','Freeze',
  'Goblin Barrel','Graveyard',
  'Void','Goblin Curse','Vines'
]);

const BUILDINGS = new Set([
  'Cannon','Mortar','Tesla','Goblin Hut','Inferno Tower','Bomb Tower','Barbarian Hut',
  'Elixir Collector','Tombstone','Furnace','Goblin Cage','X-Bow','Goblin Drill'
]);

const AIR_TROOPS = new Set([
  'Minions','Minion Horde','Bats','Baby Dragon','Inferno Dragon','Electro Dragon',
  'Skeleton Dragons','Phoenix','Mega Minion','Flying Machine','Lava Hound','Balloon'
]);

const WINCONS = new Set([
  'Hog Rider','Balloon','Giant','Golem','Lava Hound','Goblin Giant','Royal Giant',
  'Miner','Graveyard','Goblin Barrel','Goblin Drill','Battle Ram','Ram Rider',
  'X-Bow','Mortar','Elixir Golem','Electro Giant','Three Musketeers'
]);

const TANKS = new Set([
  'Giant','Golem','Lava Hound','Royal Giant','Goblin Giant','Electro Giant',
  'P.E.K.K.A','Mega Knight','Giant Skeleton','Elixir Golem','Rune Giant'
]);

const CONTROL = new Set([
  'Tornado','Freeze','Ice Wizard','Electro Wizard','Zappies','Lightning',
  'Fisherman','Monk','Vines','Earthquake','Poison','The Log','Giant Snowball','Zap'
]);

const SPAWNERS = new Set([
  'Tombstone','Goblin Hut','Barbarian Hut','Furnace','Goblin Drill','Goblin Cage',
  'Graveyard','Royal Delivery','Mother Witch','Goblin Curse'
]);

const SIEGE = new Set(['X-Bow','Mortar']);
const ECONOMY = new Set(['Elixir Collector']);

// --- family hints (lightweight semantic tags; avoids using every name token) ---
const FAMILY_HINTS = new Map([
  ['Guards', ['skeleton','shield']],
  ['Bomber', ['bomb']],
  ['Bomb Tower', ['bomb','tower']],
  ['Giant Skeleton', ['skeleton','bomb']],

  ['Wizard', ['wizard','magic']],
  ['Ice Wizard', ['wizard','ice']],
  ['Electro Wizard', ['wizard','electro']],
  ['Magic Archer', ['archer','magic']],

  ['Battle Ram', ['ram','charge']],
  ['Ram Rider', ['ram','charge']],
  ['Miner', ['miner','burrow']],
  ['Goblin Drill', ['goblin','burrow']],

  ['Goblin Hut', ['goblin','spawner']],
  ['Goblin Cage', ['goblin']],
  ['Goblin Barrel', ['goblin']],
  ['Goblin Curse', ['goblin','curse']],
  ['Tombstone', ['skeleton','spawner']],
  ['Graveyard', ['skeleton','spawner']],

  ['Furnace', ['fire','spirit','spawner']],
  ['Barbarian Hut', ['barbarian','spawner']],

  ['Inferno Tower', ['inferno','fire']],
  ['Inferno Dragon', ['inferno','fire','dragon']],
  ['Electro Dragon', ['electro','dragon']],
  ['Tesla', ['electro']],
  ['Zap', ['electro']],
  ['Lightning', ['electro']],

  ['Freeze', ['ice']],
  ['Giant Snowball', ['ice']],
  ['Ice Spirit', ['ice','spirit']],
  ['Fire Spirit', ['fire','spirit']],
  ['Poison', ['poison']],
  ['Void', ['dark']],
  ['Rage', ['rage','buff']],
  ['The Log', ['log','knockback']],

  ['Elixir Collector', ['elixir','economy']],
  ['Elixir Golem', ['elixir']],
]);

// Extra override tags (kept from your version)
const OVERRIDE_TAGS = {
  'Mother Witch': { visuals:['granny','blue eyes','purple','pink'], families:['witch','curse','hog'], mechanics:['curse','transform','spawn'] },
  'Phoenix': { visuals:['phoenix','fire bird','egg'], families:['phoenix','fire'], mechanics:['revive','egg','death_damage'] },
  'Goblin Machine': { visuals:['baby goblin','goggles','machine','rocket'], families:['goblin','machine'], mechanics:['rocket','hybrid'] },
  'Spirit Empress': { visuals:['gold armor','blonde','blue dragon','two forms'], families:['spirit','royal','dragon'], mechanics:['dual_form','air_ground'] },
  'Mighty Miner': { visuals:['orange mustache','helmet','drill'], families:['miner','machine'], mechanics:['ramp_damage','lane_swap','bomb'] },
  'Skeleton King': { visuals:['crown','spiked club'], families:['skeleton','royal'], mechanics:['soul','summon'] },
  'Archer Queen': { visuals:['purple hair','crown','cape'], families:['royal','archer'], mechanics:['cloak','speed_boost'] },
  'Golden Knight': { visuals:['gold armor','gold hair','blue eyes'], families:['royal','knight'], mechanics:['dash_chain'] },
  'Monk': { visuals:['bald','beads','white beard','reflect'], families:['monk'], mechanics:['reflect','combo','pushback'] },
  'Little Prince': { visuals:['kid','crown','crossbow','guardian'], families:['royal','prince'], mechanics:['ramp_speed','summon_guardian'] },
  'Goblinstein': { visuals:['scientist goblin','big monster','electric link'], families:['goblin','electro'], mechanics:['stun','dual_unit','ability'] },
  'Boss Bandit': { visuals:['red hair','cape','covered face'], families:['bandit'], mechanics:['dash','invis','teleport','grenades'] }
};

function cardType(name){
  if(SPELLS.has(name)) return 'spell';
  if(BUILDINGS.has(name)) return 'building';
  return 'troop';
}

function movement(name){
  const t = cardType(name);
  if(t === 'building') return 'static';
  if(t === 'spell') return 'spell';
  return AIR_TROOPS.has(name) ? 'air' : 'ground';
}

function baseRoles(name){
  const roles = [];
  if(WINCONS.has(name)) roles.push('wincon');
  if(TANKS.has(name)) roles.push('tank');
  if(CONTROL.has(name)) roles.push('control');
  if(SPAWNERS.has(name)) roles.push('spawner');
  if(SIEGE.has(name)) roles.push('siege');
  if(ECONOMY.has(name)) roles.push('economy');

  if(roles.length === 0){
    const t = cardType(name);
    if(t === 'spell') roles.push('spell');
    else if(t === 'building') roles.push('defense');
    else roles.push('dps');
  }
  return roles;
}

function primaryRole(roles){
  const order = ['wincon','tank','siege','control','spawner','economy','dps','defense','spell'];
  for(const r of order) if(roles.includes(r)) return r;
  return roles[0] || 'dps';
}

function normName(name){
  return name
    .toLowerCase()
    .replace(/p\.?e\.?k\.?k\.?a/g, 'pekka')
    .replace(/x-?bow/g, 'xbow')
    .replace(/[^a-z0-9 ]/g,' ')
    .replace(/\s+/g,' ')
    .trim();
}

function tokenSet(name){
  const n = normName(name);
  const set = new Set(n.split(' ').filter(Boolean));
  if(set.has('electro')) set.add('electric');
  return set;
}

function bigramSet(str){
  const s = str.replace(/\s+/g,'');
  const out = new Set();
  for(let i=0;i<s.length-1;i++) out.add(s.slice(i,i+2));
  return out;
}

function jaccard(A, B){
  if(A.size === 0 && B.size === 0) return 0;
  let inter = 0;
  for(const x of A) if(B.has(x)) inter++;
  const union = A.size + B.size - inter;
  return union ? (inter / union) : 0;
}

function nameSim(aName, bName){
  const A = bigramSet(normName(aName));
  const B = bigramSet(normName(bName));
  return jaccard(A, B);
}

function addHintsFromMaps(name, families, mechanics, visuals){
  const hints = FAMILY_HINTS.get(name);
  if(hints){
    for(const h of hints){
      families.add(h);
      if(h === 'burrow') mechanics.add('burrow');
      if(h === 'charge') mechanics.add('dash');
      if(h === 'knockback') mechanics.add('knockback');
      if(h === 'buff') mechanics.add('buff');
      if(h === 'curse') mechanics.add('curse');
      if(h === 'spawner') mechanics.add('spawn');
    }
  }
  const o = OVERRIDE_TAGS[name];
  if(o?.families) o.families.forEach(x => families.add(x));
  if(o?.mechanics) o.mechanics.forEach(x => mechanics.add(x));
  if(o?.visuals) o.visuals.forEach(x => visuals.add(x));
}

function inferElement(families, mechanics, tokens, visuals){
  const preferred = ['electro','ice','fire','poison','dark','spirit','inferno'];
  for(const e of preferred){
    if(families.has(e) || mechanics.has(e) || tokens.has(e) || visuals.has(e) || tokens.has(e === 'electro' ? 'electric' : e)) return e;
  }
  return null;
}

function inferSilhouette(type, move, families, roles){
  if(type === 'spell') return 'spell';
  if(type === 'building') return 'building';
  if(families.has('dragon')) return 'dragon';
  if(families.has('skeleton') || families.has('undead')) return 'undead';
  if(families.has('goblin')) return 'goblin';
  if(roles.includes('tank')) return 'big';
  if(roles.includes('spawner')) return 'spawner';
  if(move === 'air') return 'flying';
  if(families.has('ram') || families.has('hog')) return 'mount';
  if(families.has('archer')) return 'ranged';
  return 'humanoid';
}

const CARD_DB = new Map();
const SIM_CACHE = new Map();

function buildCardDB(){
  CARD_DB.clear();
  SIM_CACHE.clear();

  for(const name of CLASH_CARDS){
    const type = cardType(name);
    const move = movement(name);
    const roles = baseRoles(name);
    const tokens = tokenSet(name);

    const families = new Set();
    const mechanics = new Set();
    const visuals = new Set();

    const keepFamilies = new Set([
      'goblin','skeleton','dragon','spirit','royal','barbarian','witch','wizard','archer',
      'prince','knight','giant','miner','hog','ram','bandit','phoenix','elixir','bomb','monk'
    ]);
    for(const t of tokens) if(keepFamilies.has(t)) families.add(t);

    if(tokens.has('freeze')) mechanics.add('freeze');
    if(tokens.has('tornado')) mechanics.add('pull');
    if(tokens.has('zap') || tokens.has('electro') || tokens.has('lightning') || tokens.has('tesla')) mechanics.add('stun');
    if(tokens.has('poison')) mechanics.add('dot');
    if(tokens.has('rage')) mechanics.add('buff');
    if(tokens.has('clone') || tokens.has('mirror')) mechanics.add('copy');
    if(tokens.has('log') || tokens.has('snowball')) mechanics.add('knockback');
    if(tokens.has('barrel')) mechanics.add('roll');
    if(tokens.has('drill') || tokens.has('miner')) mechanics.add('burrow');
    if(tokens.has('bandit') || tokens.has('prince') || tokens.has('ram')) mechanics.add('dash');

    if(SPAWNERS.has(name)) mechanics.add('spawn');
    if(name === 'Inferno Tower' || name === 'Inferno Dragon') mechanics.add('ramp');
    if(name === 'Phoenix') mechanics.add('revive');

    if(tokens.has('ice') || tokens.has('snow')) visuals.add('blue');
    if(tokens.has('fire') || tokens.has('inferno') || tokens.has('phoenix')) visuals.add('fire');
    if(tokens.has('electro') || tokens.has('zap') || tokens.has('lightning') || tokens.has('tesla')) visuals.add('electric');
    if(tokens.has('goblin')) visuals.add('green');
    if(tokens.has('skeleton') || tokens.has('grave')) visuals.add('undead');
    if(tokens.has('royal') || tokens.has('king') || tokens.has('queen') || tokens.has('prince') || tokens.has('knight')) visuals.add('crown');

    addHintsFromMaps(name, families, mechanics, visuals);

    const element = inferElement(families, mechanics, tokens, visuals);
    const silhouette = inferSilhouette(type, move, families, roles);

    CARD_DB.set(name, {
      name, type, move,
      roles,
      primary: primaryRole(roles),
      families: [...families],
      mechanics: [...mechanics],
      visuals: [...visuals],
      element,
      silhouette
    });
  }
}

function overlapCount(aArr, bArr){
  const B = new Set(bArr);
  let c = 0;
  for(const x of aArr) if(B.has(x)) c++;
  return c;
}

function similarityScore(real, cand){
  if(BAD_PAIRS.has(pairKey(real, cand))) return -Infinity;

  const A = CARD_DB.get(real);
  const B = CARD_DB.get(cand);
  if(!A || !B || real === cand) return -Infinity;

  const ns = nameSim(real, cand);
  const famOv = overlapCount(A.families, B.families);
  const mecOv = overlapCount(A.mechanics, B.mechanics);
  const roleOv = overlapCount(A.roles, B.roles);
  const visOv = overlapCount(A.visuals, B.visuals);

  const typeMatch = (A.type === B.type);
  const moveMatch = (A.move === B.move);
  const elementMatch = (A.element && A.element === B.element);
  const silMatch = (A.silhouette === B.silhouette);
  const roleMatch = (A.primary === B.primary);

  const meaningful = !!(elementMatch || famOv >= 1 || mecOv >= 1 || ns >= 0.33);
  if(!meaningful) return -Infinity;

  let s = 0;

  s += elementMatch ? 26 : 0;
  s += typeMatch ? 18 : 0;
  s += moveMatch ? 16 : 0;
  s += silMatch ? 14 : 0;

  s += roleMatch ? 8 : 0;
  s += Math.min(14, mecOv * 7);
  s += Math.min(12, famOv * 6);
  s += Math.min(8,  roleOv * 3);
  s += Math.min(6,  visOv * 2);

  s += ns * 5;

  if(typeMatch && !elementMatch && famOv === 0 && mecOv === 0 && ns < 0.35){
    s -= 18;
  }

  return { score: s, ns };
}

function coreMatchCount(A, B, ns){
  const famOv = overlapCount(A.families, B.families);
  const mecOv = overlapCount(A.mechanics, B.mechanics);

  let core = 0;
  if(A.element && A.element === B.element) core += 2;
  if(A.type === B.type) core++;
  if(A.move === B.move) core++;
  if(A.silhouette === B.silhouette) core++;
  if(A.primary === B.primary) core++;
  if(famOv >= 1) core++;
  if(mecOv >= 1) core++;
  if(ns >= 0.40) core++;

  return core;
}

function rankedCandidates(real, difficulty){
  const key = `${real}__${difficulty}`;
  if(SIM_CACHE.has(key)) return SIM_CACHE.get(key);

  const out = [];
  for(const c of CLASH_CARDS){
    if(c === real) continue;

    const base = similarityScore(real, c);
    if(base === -Infinity) continue;

    const A = CARD_DB.get(real);
    const B = CARD_DB.get(c);
    const core = coreMatchCount(A, B, base.ns);

    let minCore = 0;
    let minScore = 0;
    if(difficulty === 'easy'){ minCore = 7; minScore = 62; }
    else if(difficulty === 'medium'){ minCore = 6; minScore = 50; }
    else { minCore = 5; minScore = 42; }

    if(core < minCore) continue;
    if(base.score < minScore) continue;

    out.push({ c, s: base.score });
  }

  out.sort((a,b)=>b.s-a.s);

  let pool;
  if(difficulty === 'easy') pool = out.slice(0, 18);
  else if(difficulty === 'medium') pool = out.slice(0, 28);
  else pool = out.slice(0, 36);

  if(pool.length < 10){
    const fallback = [];
    for(const c of CLASH_CARDS){
      if(c === real) continue;
      const base = similarityScore(real, c);
      if(base === -Infinity) continue;

      const A = CARD_DB.get(real);
      const B = CARD_DB.get(c);
      const core = coreMatchCount(A, B, base.ns);

      if(core >= 4) fallback.push({ c, s: base.score });
    }
    fallback.sort((a,b)=>b.s-a.s);
    pool = fallback.slice(0, difficulty === 'easy' ? 16 : (difficulty === 'medium' ? 24 : 30));
  }

  SIM_CACHE.set(key, pool);
  return pool;
}

function weightedPick(arr){
  if(arr.length === 1) return arr[0];
  let total = 0;
  for(let i=0;i<arr.length;i++) total += (arr.length - i);
  let r = Math.random() * total;
  for(let i=0;i<arr.length;i++){
    r -= (arr.length - i);
    if(r <= 0) return arr[i];
  }
  return arr[0];
}

function pickFakeCard(real, difficulty, avoidSet = new Set()){
  const ranked = rankedCandidates(real, difficulty);
  const pool = ranked.map(x => x.c);

  const filtered = pool.filter(c => c !== real && !avoidSet.has(c));
  const use = filtered.length ? filtered : pool.filter(c => c !== real);

  if(!use.length){
    let c = real;
    for(let t=0;t<10 && c===real;t++){
      c = CLASH_CARDS[Math.floor(Math.random()*CLASH_CARDS.length)];
    }
    return c === real ? (CLASH_CARDS.find(x=>x!==real) || real) : c;
  }

  const topN = (difficulty === 'easy') ? 6 : (difficulty === 'medium' ? 10 : 14);
  const slice = use.slice(0, Math.min(topN, use.length));
  return weightedPick(slice);
}
