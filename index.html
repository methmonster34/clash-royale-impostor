function rankScorePrecise(base, cand){
  const A = meta(base), B = meta(cand);
  let s = 0;
  // weights reflect your importance order AFTER hard filters
  if (A.towerOnly === B.towerOnly) s += 3;       // closer tower-aim behavior
  if (A.dmg && B.dmg && A.dmg === B.dmg) s += 2; // spell/building dmg type
  if (A.role === B.role) s += 2;                 // same role bucket
  if (A.swarm === B.swarm) s += 1;               // small bias for swarm match
  return s;
}

function pickTopRandom(scored){
  if(!scored.length) return undefined;
  const sorted = scored.slice().sort((a,b)=>b.s-a.s);
  const top = sorted[0].s;
  const topGroup = sorted.filter(x=>x.s===top);
  return topGroup[Math.floor(Math.random()*topGroup.length)].c;
}

function pickSimilar(base, difficulty='easy'){
  const A = meta(base);
  const candidates = CLASH_CARDS.filter(c => c !== base);

  // 1) STARTING POOL by group: spell | building | ground | air
  let pool = candidates.filter(c => meta(c).group === A.group);

  // If empty (rare), widen 1 notch (e.g., no air â†’ use all troops of same type)
  if(!pool.length && (A.group==='air' || A.group==='ground')){
    pool = candidates.filter(c => meta(c).type === 'troop');
  }

  // 2) STRICT FILTERS in priority order; relax stage-by-stage per difficulty
  // stages define how many strict filters we require before relaxing
  const stagesByDiff = { easy: 3, medium: 2, hard: 1, chaos: 0 };
  let stage = stagesByDiff[difficulty] ?? 3;

  // Build ordered tests: towerOnly first, then dmg type (for spells/buildings), then role
  const tests = [];
  tests.push((M)=> M.towerOnly === A.towerOnly);
  if (A.type==='spell' || A.type==='building') tests.push((M)=> M.dmg === A.dmg);
  tests.push((M)=> M.role === A.role);

  let narrowed = [];
  while(stage >= 0 && !narrowed.length){
    narrowed = pool.filter(c => {
      const M = meta(c);
      // require first `stage` tests to pass
      for(let i=0;i<stage;i++){
        if(!tests[i]) break;
        if(!tests[i](M)) return false;
      }
      return true;
    });
    stage--;
  }
  pool = narrowed.length ? narrowed : pool;

  // 3) HARD mode spice: 40% let best overall within same group bypass strictness
  if(difficulty==='hard' && Math.random()<0.4){
    const scoredAll = pool.map(c => ({ c, s: rankScorePrecise(base, c) }));
    const pick = pickTopRandom(scoredAll);
    if(pick) return pick;
  }

  // 4) Rank remaining and tie-break
  const scored = pool.map(c => ({ c, s: rankScorePrecise(base, c) }));
  const choice = pickTopRandom(scored);
  if(choice) return choice;

  // 5) Fallback: random different card
  return candidates[Math.floor(Math.random()*candidates.length)];
}
